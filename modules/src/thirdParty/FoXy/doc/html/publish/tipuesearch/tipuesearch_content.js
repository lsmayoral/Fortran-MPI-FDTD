var tipuesearch = {"pages":[{"title":" FoXy ","text":"FoXy ! md_extensions: markdown.extensions.toc(anchorlink=True)\nmd_extensions: markdown.extensions.toc()\n               markdown.extensions.smarty(smart_quotes=False)\n               markdown.extensions.extra\n               markdown_checklist.extension\ndocmark: <\ndisplay: public\n         protected\n         private\nsource: true\nwarn: true\ngraph: true\nextra_mods: iso_fortran_env:https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html Developer Info Fortran-FOSS-Programmers Group","tags":"home","loc":"index.html"},{"title":"add_attributes.f90 – FoXy","text":"Contents Programs add_attributes Source Code add_attributes.f90 Source Code !< FoXy test. program add_attributes !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file , xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) parsed = a_tag % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) call a_tag % add_attributes ( attributes_stream = 'y=\"3\" a=\"one\" b = \"two\" cc=\"tree\"' ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"3\" z=\"2\" a=\"one\" b=\"two\" cc=\"tree\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' parsed = a_tag % stringify () test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) call a_tag % add_attributes ( attributes_stream = '' ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"3\" z=\"2\" a=\"one\" b=\"two\" cc=\"tree\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' parsed = a_tag % stringify () test_passed ( 3 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram add_attributes","tags":"","loc":"sourcefile/add_attributes.f90.html"},{"title":"parse_string_simple.f90 – FoXy","text":"Contents Programs parse_string_simple Source Code parse_string_simple.f90 Source Code !< FoXy test. program parse_string_simple !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'Parsing file' call xfile % parse ( string = source ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram parse_string_simple","tags":"","loc":"sourcefile/parse_string_simple.f90.html"},{"title":"delete_content.f90 – FoXy","text":"Contents Programs delete_content Source Code delete_content.f90 Source Code !< FoXy test. program delete_content !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'delete content' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_content () parsed = a_tag % stringify () source = '<first x=\"1\" y=\"c\" z=\"2\"></first>' test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram delete_content","tags":"","loc":"sourcefile/delete_content.f90.html"},{"title":"create_tag.f90 – FoXy","text":"Contents Programs create_tag Source Code create_tag.f90 Source Code !< FoXy test. program create_tag !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ! create using xml_tag overloaded procedures print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) parsed = a_tag % stringify () test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // 'Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '<second x=\"1\" y=\"c\" z=\"2\"/>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'second' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ]), is_self_closing = . true .) parsed = a_tag % stringify () test_passed ( 2 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) ! create parsing a source print \"(A)\" , 'source' source = '<third x=\"1\" y=\"c\" z=\"2\"/>' print \"(A)\" , source print \"(A)\" , 'created' call a_tag % set ( name = 'third' ) call a_tag % parse ( source = source ) parsed = a_tag % stringify () test_passed ( 3 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A)\" , 'source' source = '<fourth x=\"1\" y=\"c\" z=\"2\"></fourth>' print \"(A)\" , source print \"(A)\" , 'created' call a_tag % set ( name = 'fourth' ) call a_tag % parse ( source = source ) parsed = a_tag % stringify () test_passed ( 4 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 4 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram create_tag","tags":"","loc":"sourcefile/create_tag.f90.html"},{"title":"add_tag.f90 – FoXy","text":"Contents Programs add_tag Source Code add_tag.f90 Source Code !< FoXy test. program add_tag !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file , xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: a_file !< XML tag handler. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_tag ) :: another_tag !< XML tag handler. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested l=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'second' , attribute = [ 'a1' , '2 ' ], is_self_closing = . true ., sanitize_attributes_value = . true .) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'third' , content = 'bye' ) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'fourth' , content = 'bye bye Mrs. Robinson' , attribute = [ 'a' , '3' ]) call a_file % add_tag ( tag = a_tag ) another_tag = xml_tag ( name = 'nested' , content = 'I am supported! Nested tag at level 1' , attribute = [ 'l' , '1' ]) a_tag = xml_tag ( name = 'fift' , content = another_tag , is_content_indented = . true .) call a_file % add_tag ( tag = a_tag ) parsed = a_file % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram add_tag","tags":"","loc":"sourcefile/add_tag.f90.html"},{"title":"delete_attributes.f90 – FoXy","text":"Contents Programs delete_attributes Source Code delete_attributes.f90 Source Code !< FoXy test. program delete_attributes !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'delete \"y\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"y\" ) parsed = a_tag % stringify () source = '<first x=\"1\" z=\"2\">lorem ipsum...</first>' test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'delete \"x\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"x\" ) parsed = a_tag % stringify () source = '<first y=\"c\" z=\"2\">lorem ipsum...</first>' test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A)\" , 'delete \"z\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"z\" ) parsed = a_tag % stringify () source = '<first x=\"1\" y=\"c\">lorem ipsum...</first>' test_passed ( 3 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A)\" , 'delete \"x\" \"z\" attributes' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = [ \"z\" , \"x\" ]) parsed = a_tag % stringify () source = '<first y=\"c\">lorem ipsum...</first>' test_passed ( 4 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 4 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram delete_attributes","tags":"","loc":"sourcefile/delete_attributes.f90.html"},{"title":"write_tag.f90 – FoXy","text":"Contents Programs write_tag Source Code write_tag.f90 Source Code !< FoXy test. program write_tag !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' ) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">' // new_line ( 'a' ) // '  lorem ipsum...' // new_line ( 'a' ) // '</first>' print \"(A)\" , source a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., is_content_indented = . true .) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 2 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 2 ) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., only_start = . true ., end_record = new_line ( 'a' )) call a_tag % write ( unit = xunit , form = 'unformatted' , is_content_indented = . true ., only_content = . true ., end_record = new_line ( 'a' )) call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., only_end = . true .) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 3 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 3 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram write_tag","tags":"","loc":"sourcefile/write_tag.f90.html"},{"title":"parse_file_simple.f90 – FoXy","text":"Contents Programs parse_file_simple Source Code parse_file_simple.f90 Source Code !< FoXy test. program parse_file_simple !< FoXy test. use foxy , only : xml_file implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' ) write ( unit = xunit ) source close ( unit = xunit ) print \"(A)\" , 'Parsing file' call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram parse_file_simple","tags":"","loc":"sourcefile/parse_file_simple.f90.html"},{"title":"delete_tag.f90 – FoXy","text":"Contents Programs delete_tag Source Code delete_tag.f90 Source Code !< FoXy test. program delete_tag !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file , xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: a_file !< XML tag handler. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_tag ) :: another_tag !< XML tag handler. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' print \"(A)\" , source print \"(A)\" , 'parsed' call a_file % parse ( string = source ) print \"(A)\" , 'remove \"third\" tag' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' call a_file % delete_tag ( name = \"third\" ) parsed = a_file % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'remove \"first\" tag' source = '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' call a_file % delete_tag ( name = \"first\" ) parsed = a_file % stringify () test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram delete_tag","tags":"","loc":"sourcefile/delete_tag.f90.html"},{"title":"indent_tag.f90 – FoXy","text":"Contents Programs indent_tag Source Code indent_tag.f90 Source Code !< FoXy test. program indent_tag !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'source' source = '  <first>lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , indent = 2 ) parsed = a_tag % stringify ( is_indented = . true .) test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '  <first>' // new_line ( 'a' ) // & '    lorem ipsum...' // new_line ( 'a' ) // & '  </first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , indent = 2 ) parsed = a_tag % stringify ( is_indented = . true ., is_content_indented = . true .) test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram indent_tag","tags":"","loc":"sourcefile/indent_tag.f90.html"},{"title":"foxy_xml_file.f90 – FoXy","text":"Contents Modules foxy_xml_file Source Code foxy_xml_file.f90 Source Code !< FoXy XML file class. module foxy_xml_file !< FoXy XML file class. use foxy_xml_tag , only : xml_tag use penf implicit none private type , public :: xml_file !< XML file class. !< !< @todo The \"delete\" facility is incomplete: nested tags are not taken into account. Better support will with the !< \"dom\" facility. private integer ( I4P ) :: Nt = 0 !< Number of XML tags. type ( xml_tag ), allocatable :: tag (:) !< XML tags array. contains ! public methods procedure :: free !< Free dynamic memory. procedure :: parse !< Parse xml data from string or file. procedure :: content !< Return tag content of tag named *name*. procedure :: stringify !< Convert the whole file data into a string. procedure :: add_tag !< Add tag to XML file. procedure :: delete_tag !< Add tag from XML file. final :: finalize !< Free dynamic memory when finalizing. ! private methods procedure , private :: parse_from_string !< Parse xml data from string. endtype xml_file contains ! public methods elemental subroutine free ( self ) !< Free dynamic memory. class ( xml_file ), intent ( inout ) :: self !< XML file. if ( allocated ( self % tag )) then call self % tag % free deallocate ( self % tag ) self % Nt = 0 endif endsubroutine free subroutine finalize ( file ) !< Free dynamic memory when finalizing. type ( xml_file ), intent ( inout ) :: file !< XML file. call file % free endsubroutine finalize subroutine parse ( self , string , filename ) !< Parse xml data from string or file. !< !< @note Self data are free before trying to parse new xml data: all previously parsed data are lost. class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), optional , intent ( in ) :: string !< String containing xml data. character ( * ), optional , intent ( in ) :: filename !< File name containing xml data. character ( len = :), allocatable :: source !< String containing xml data. call self % free if ( present ( string )) then call self % parse_from_string ( source_string = string ) elseif ( present ( filename )) then source = load_file_as_stream ( filename = filename , fast_read = . true .) call self % parse_from_string ( source_string = source ) endif endsubroutine parse pure function content ( self , name ) !< Return tag content of tag named *name*. !< !< @note If there is no value, the *tag_content* string is returned empty, but allocated. class ( xml_file ), intent ( in ) :: self !< XML file. character ( * ), intent ( in ) :: name !< Tag name. character ( len = :), allocatable :: content !< Tag content. integer ( I4P ) :: t !< Counter. if ( allocated ( content )) deallocate ( content ) if ( self % Nt > 0 ) then do t = 1 , self % Nt call self % tag ( t )% get_content ( name = name , content = content ) if ( allocated ( content )) exit enddo endif if (. not . allocated ( content )) content = '' endfunction content pure function stringify ( self ) result ( string ) !< Convert the whole file data into a string. class ( xml_file ), intent ( in ) :: self !< XML file. character ( len = :), allocatable :: string !< Output string containing the whole xml file. character ( len = :), allocatable :: tag_string !< Output string containing the current tag. integer ( I4P ) :: t !< Counter. string = '' if ( self % Nt > 0 ) then do t = 1 , self % Nt - 1 tag_string = self % tag ( t )% stringify () string = string // tag_string // new_line ( 'a' ) enddo tag_string = self % tag ( self % Nt )% stringify () string = string // tag_string endif endfunction stringify elemental subroutine add_tag ( self , tag ) !< Add tag to XML file. class ( xml_file ), intent ( inout ) :: self !< XML file. type ( xml_tag ), intent ( in ) :: tag !< XML tag. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. if ( self % Nt > 0_I4P ) then allocate ( tag_new ( 1 : self % Nt + 1 )) tag_new ( 1 : self % Nt ) = self % tag ( 1 : self % Nt ) tag_new ( self % Nt + 1 ) = tag else allocate ( tag_new ( 1 : 1 )) tag_new ( 1 ) = tag endif call move_alloc ( from = tag_new , to = self % tag ) self % Nt = self % Nt + 1 endsubroutine add_tag elemental subroutine delete_tag ( self , name ) !< Delete tag from XML file. class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), intent ( in ) :: name !< XML tag name. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. integer ( I4P ) :: t !< Counter. if ( self % Nt > 0_I4P ) then do t = 1 , self % Nt if ( name == self % tag ( t )% name ()) then allocate ( tag_new ( 1 : self % Nt - 1 )) if ( t == 1 ) then tag_new ( t :) = self % tag ( t + 1 :) elseif ( t == self % Nt ) then tag_new (: t - 1 ) = self % tag (: t - 1 ) else tag_new (: t - 1 ) = self % tag (: t - 1 ) tag_new ( t :) = self % tag ( t + 1 :) endif call move_alloc ( from = tag_new , to = self % tag ) self % Nt = self % Nt - 1 exit endif enddo endif endsubroutine delete_tag ! private methods subroutine parse_from_string ( self , source_string ) !< Parse xml data from string. class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), intent ( in ) :: source_string !< String containing xml data. type ( xml_tag ) :: tag !< Dummy xml tag. integer ( I4P ) :: tstart !< Counter for tracking string parsing. integer ( I4P ) :: tend !< Counter for tracking string parsing. tstart = 1 tend = 0 do while ( tstart < len ( source_string )) call tag % free call tag % parse ( source = source_string ( tstart :), tend = tend ) if ( tend == 0 ) exit if ( tag % is_parsed ()) call self % add_tag ( tag ) tstart = tstart + tend enddo endsubroutine parse_from_string ! non TBP function load_file_as_stream ( filename , delimiter_start , delimiter_end , fast_read , iostat , iomsg ) result ( stream ) !< Load file contents and store as single characters stream. character ( * ), intent ( in ) :: filename !< File name. character ( * ), optional , intent ( in ) :: delimiter_start !< Delimiter from which start the stream. character ( * ), optional , intent ( in ) :: delimiter_end !< Delimiter to which end the stream. logical , optional , intent ( in ) :: fast_read !< Flag for activating efficient reading with one single read. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: stream !< Output string containing the file data as a single stream. logical :: is_file !< Flag for inquiring the presence of the file. integer ( I4P ) :: unit !< Unit file. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< IO error message. character ( 1 ) :: c1 !< Single character. character ( len = :), allocatable :: string !< Dummy string. logical :: cstart !< Flag for stream capturing trigging. logical :: cend !< Flag for stream capturing trigging. logical :: fast !< Flag for activating efficient reading with one single read. integer ( I4P ) :: filesize !< Size of the file for fast reading. fast = . false . ; if ( present ( fast_read )) fast = fast_read ! inquire file existance inquire ( file = adjustl ( trim ( filename )), exist = is_file , iostat = iostatd , iomsg = iomsgd ) if (. not . is_file ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! open file open ( newunit = unit , file = adjustl ( trim ( filename )), access = 'STREAM' , form = 'UNFORMATTED' , iostat = iostatd , iomsg = iomsgd ) if ( iostatd /= 0 ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! loadg data stream = '' if ( present ( delimiter_start ). and . present ( delimiter_end )) then ! load only data inside delimiter_start and delimiter_end string = '' Main_Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_start ( 1 : 1 )) then cstart = . true . string = c1 Start_Read_Loop : do while ( len ( string ) < len ( delimiter_start )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_start , substring = string ) > 0 )) then cstart = . false . exit Start_Read_Loop endif enddo Start_Read_Loop if ( cstart ) then cend = . false . stream = string do while (. not . cend ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_end ( 1 : 1 )) then ! maybe the end string = c1 End_Read_Loop : do while ( len ( string ) < len ( delimiter_end )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_end , substring = string ) > 0 )) then stream = stream // string exit End_Read_Loop elseif ( len ( string ) == len ( delimiter_end )) then cend = . true . stream = stream // string exit Main_Read_Loop endif enddo End_Read_Loop else stream = stream // c1 endif enddo endif endif enddo Main_Read_Loop else ! load all data if ( fast ) then ! load fast inquire ( file = adjustl ( trim ( filename )), size = filesize , iostat = iostatd , iomsg = iomsgd ) if ( iostatd == 0 ) then if ( allocated ( stream )) deallocate ( stream ) allocate ( character ( len = filesize ) :: stream ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) stream endif else ! load slow, one character loop Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 stream = stream // c1 enddo Read_Loop endif endif 10 close ( unit ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endfunction load_file_as_stream endmodule foxy_xml_file","tags":"","loc":"sourcefile/foxy_xml_file.f90.html"},{"title":"foxy_xml_tag.F90 – FoXy","text":"Contents Modules foxy_xml_tag Source Code foxy_xml_tag.F90 Source Code !< FoXy XML tag class. module foxy_xml_tag !< FoXy XML tag class. use penf use stringifor implicit none private public :: xml_tag type :: xml_tag !< XML tag class. !< !< A valid XML tag must have the following syntax for a tag without a content (with only attributes): !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\"/> !<``` !< while a tag with a content must have the following syntax: !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\">Tag_Content</Tag_Name> !<``` !< !< It is worth noting that the syntax is case sensitive and that the attributes are optional. Each attribute name must be followed !< by '=\"' without any additional white spaces and its value must be termined by '\"'. Each attribute is separated by one or more !< white spaces. private type ( string ) :: tag_name !< Tag name. type ( string ) :: tag_content !< Tag content. type ( string ), allocatable :: attribute (:,:) !< Attributes names/values pairs, [1:2, 1:]. integer ( I4P ) :: attributes_number = 0 !< Number of defined attributes. integer ( I4P ) :: indent = 0 !< Number of indent-white-spaces. logical :: is_self_closing = . false . !< Self closing tag flag. contains ! public methods generic :: add_attributes => & add_single_attribute , & add_multiple_attributes , & add_stream_attributes !< Add attributes name/value pairs. procedure , pass ( self ) :: attributes !< Return attributes name/value pairs as string. procedure , pass ( self ) :: get_content !< Return tag content. generic :: delete_attributes => & delete_single_attribute , & delete_multiple_attributes !< Delete attributes name/value pairs. procedure , pass ( self ) :: delete_content !< Delete tag conent. procedure , pass ( self ) :: end_tag !< Return `</tag_name>` end tag. procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: is_attribute_present !< Return .true. it the queried attribute name is defined. procedure , pass ( self ) :: is_parsed !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. procedure , pass ( self ) :: name !< Return tag name. procedure , pass ( self ) :: parse !< Parse the tag contained into a source string. procedure , pass ( self ) :: self_closing_tag !< Return `<tag_name.../>` self closing tag. procedure , pass ( self ) :: set !< Set tag data. procedure , pass ( self ) :: start_tag !< Return `<tag_name...>` start tag. procedure , pass ( self ) :: stringify !< Convert the whole tag into a string. procedure , pass ( self ) :: write => write_tag !< Write tag to unit file. generic :: assignment ( = ) => assign_tag !< Assignment operator overloading. ! private methods procedure , pass ( self ), private :: add_single_attribute !< Add one attribute name/value pair. procedure , pass ( self ), private :: add_multiple_attributes !< Add list of attributes name/value pairs. procedure , pass ( self ), private :: add_stream_attributes !< Add list of attributes name/value pairs passed as stream. procedure , pass ( self ), private :: alloc_attributes !< Allocate (prepare for filling) dynamic memory of attributes. procedure , pass ( self ), private :: delete_single_attribute !< Delete one attribute name/value pair. procedure , pass ( self ), private :: delete_multiple_attributes !< Delete list of attributes name/value pairs. procedure , pass ( self ), private :: get !< Get the tag value and attributes from source. procedure , pass ( self ), private :: get_value !< Get the tag value from source after tag_name has been set. procedure , pass ( self ), private :: get_attributes !< Get the attributes values from source. procedure , pass ( self ), private :: parse_tag_name !< Parse the tag name contained into a string. procedure , pass ( self ), private :: parse_attributes_names !< Parse the tag attributes names contained into a string. procedure , pass ( self ), private :: search !< Search tag named *tag_name* into a string. ! operators procedure , pass ( lhs ), private :: assign_tag !< Assignment between two tags. #if (__GNUC__ < 9) final :: finalize !< Free dynamic memory when finalizing. #endif endtype xml_tag interface xml_tag !< Overload *xml_tag* with creator procedures. module procedure create_tag_flat , create_tag_nested endinterface contains ! creator procedures overloading *xml_tag* name pure function create_tag_flat ( name , attribute , attributes , attributes_stream , sanitize_attributes_value , content , indent , & is_content_indented , is_self_closing ) result ( tag ) !< Return an instance of xml tag. !< !< Attributes are passed by array. character ( * ), intent ( in ) :: name !< Tag name. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list of name/value pairs as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. character ( * ), intent ( in ), optional :: content !< Tag value. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. logical , intent ( in ), optional :: is_self_closing !< The tag is self closing. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , attribute = attribute , attributes = attributes , attributes_stream = attributes_stream , & sanitize_attributes_value = sanitize_attributes_value , content = content , & indent = indent , is_content_indented = is_content_indented , is_self_closing = is_self_closing ) endfunction create_tag_flat pure function create_tag_nested ( name , content , attribute , attributes , attributes_stream , sanitize_attributes_value , indent , & is_content_indented ) result ( tag ) !< Return an instance of xml tag with value being a nested tag. !< !< Attributes are passed by array. character ( * ), intent ( in ) :: name !< Tag name. type ( xml_tag ), intent ( in ) :: content !< Tag value as nested tag.. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list of name/value pairs as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate value indentation. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , attribute = attribute , attributes = attributes , content = content % stringify (), & sanitize_attributes_value = sanitize_attributes_value , attributes_stream = attributes_stream , indent = indent , & is_content_indented = is_content_indented ) endfunction create_tag_nested ! public methods pure function attributes ( self ) result ( att_ ) !< Return attributes name/value pairs as string. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: att_ !< The attributes string. integer ( I4P ) :: a !< Counter. if ( self % attributes_number > 0 ) then att_ = '' do a = 1 , self % attributes_number att_ = att_ // ' ' // self % attribute ( 1 , a ) // '=\"' // self % attribute ( 2 , a ) // '\"' enddo att_ = trim ( adjustl ( att_ )) endif endfunction attributes pure subroutine get_content ( self , name , content ) !< Return tag content of self (or its nested tags) if named *name*. !< !< @note If there is no value, the *content* string is returned deallocated. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Searched tag name. character ( len = :), allocatable , intent ( out ) :: content !< Tag content. type ( xml_tag ) :: tag !< Dummy XML tag. if ( allocated ( content )) deallocate ( content ) if ( self % tag_name % is_allocated ()) then if ( self % tag_name == name ) then if ( self % tag_content % is_allocated ()) content = self % tag_content % chars () else if ( self % tag_content % is_allocated ()) then call tag % search ( tag_name = name , source = self % tag_content % chars ()) if ( tag % tag_content % is_allocated ()) content = tag % tag_content % chars () endif endif endif endsubroutine get_content pure function end_tag ( self , is_indented ) result ( tag_ ) !< Return `</tag_name>` end tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Activate content indentation. character ( len = :), allocatable :: tag_ !< The end tag string. tag_ = '</' // self % tag_name // '>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction end_tag elemental subroutine free ( self ) !< Free dynamic memory. class ( xml_tag ), intent ( inout ) :: self !< XML tag. call self % tag_name % free call self % tag_content % free if ( allocated ( self % attribute )) then call self % attribute % free deallocate ( self % attribute ) endif self % attributes_number = 0 self % indent = 0 self % is_self_closing = . false . endsubroutine free elemental function is_parsed ( self ) !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical :: is_parsed !< Result of check. is_parsed = self % tag_name % is_allocated () endfunction is_parsed pure function name ( self ) !< Return tag name. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: name !< XML tag name. name = self % tag_name % chars () endfunction name elemental subroutine parse ( self , source , tstart , tend ) !< Parse the tag contained into a source string. !< !< It is assumed that the first tag contained into the source string is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the string. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the string. integer ( I4P ) :: tstartd !< Starting index of tag inside the string. integer ( I4P ) :: tendd !< Ending index of tag inside the string. tstartd = 0 tendd = 0 call self % parse_tag_name ( source = source , tstart = tstartd , tend = tendd ) if ( self % tag_name % is_allocated ()) then if ( index ( string = source ( tstartd : tendd ), substring = '=' ) > 0 ) call self % parse_attributes_names ( source = source ( tstartd : tendd )) if ( index ( string = source , substring = '</' // self % tag_name // '>' ) > 0 ) & tendd = index ( string = source , substring = '</' // self % tag_name // '>' ) + len ( '</' // self % tag_name // '>' ) - 1 call self % get ( source = source ( tstartd : tendd )) endif if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd endsubroutine parse pure subroutine set ( self , name , attribute , attributes , attributes_stream , sanitize_attributes_value , content , & indent , is_content_indented , is_self_closing ) !< Set tag data. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ), optional :: name !< Tag name. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list of name/value pairs as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. character ( * ), intent ( in ), optional :: content !< Tag value. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate value indentation. logical , intent ( in ), optional :: is_self_closing !< The tag is self closing. logical :: is_content_indented_ !< Activate value indentation. if ( present ( name )) self % tag_name = name if ( present ( attribute )) call self % add_single_attribute ( attribute = attribute , sanitize_value = sanitize_attributes_value ) if ( present ( attributes )) call self % add_multiple_attributes ( attributes = attributes , sanitize_values = sanitize_attributes_value ) if ( present ( attributes_stream )) call self % add_stream_attributes ( attributes_stream = attributes_stream , & sanitize_values = sanitize_attributes_value ) if ( present ( indent )) self % indent = indent if ( present ( content )) then is_content_indented_ = . false . ; if ( present ( is_content_indented )) is_content_indented_ = is_content_indented if ( is_content_indented_ ) then self % tag_content = new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // content // new_line ( 'a' ) else self % tag_content = content endif endif if ( present ( is_self_closing )) self % is_self_closing = is_self_closing endsubroutine set pure function self_closing_tag ( self , is_indented ) result ( tag_ ) !< Return `<tag_name.../>` self closing tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Flag to check if tag is indented. character ( len = :), allocatable :: tag_ !< The self closing tag string. tag_ = '<' // self % tag_name if ( self % attributes_number > 0 ) tag_ = tag_ // ' ' // self % attributes () tag_ = tag_ // '/>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction self_closing_tag pure function start_tag ( self , is_indented ) result ( tag_ ) !< Return `<tag_name...>` start tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Flag to check if tag is indented. character ( len = :), allocatable :: tag_ !< The start tag string. tag_ = '<' // self % tag_name if ( self % attributes_number > 0 ) tag_ = tag_ // ' ' // self % attributes () tag_ = tag_ // '>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction start_tag pure function stringify ( self , is_indented , is_content_indented , only_start , only_content , only_end ) result ( stringed ) !< Convert the whole tag into a string. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Activate content indentation. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. logical , intent ( in ), optional :: only_start !< Write only start tag. logical , intent ( in ), optional :: only_content !< Write only content. logical , intent ( in ), optional :: only_end !< Write only end tag. character ( len = :), allocatable :: stringed !< Output string containing the whole tag. logical :: is_content_indented_ !< Activate content indentation. logical :: only_start_ !< Write only start tag. logical :: only_content_ !< Write only content. logical :: only_end_ !< Write only end tag. is_content_indented_ = . false . ; if ( present ( is_content_indented )) is_content_indented_ = is_content_indented only_start_ = . false . ; if ( present ( only_start )) only_start_ = only_start only_content_ = . false . ; if ( present ( only_content )) only_content_ = only_content only_end_ = . false . ; if ( present ( only_end )) only_end_ = only_end if ( only_start_ ) then stringed = self % start_tag ( is_indented = is_indented ) elseif ( only_content_ ) then if ( self % tag_content % is_allocated ()) then if ( is_content_indented_ ) then stringed = repeat ( ' ' , self % indent + 2 ) // self % tag_content else stringed = self % tag_content % chars () endif endif elseif ( only_end_ ) then stringed = self % end_tag ( is_indented = is_indented ) else stringed = '' if ( self % tag_name % is_allocated ()) then if ( self % is_self_closing ) then stringed = self % self_closing_tag ( is_indented = is_indented ) else stringed = self % start_tag ( is_indented = is_indented ) if ( self % tag_content % is_allocated ()) then if ( is_content_indented_ ) then stringed = stringed // new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // & self % tag_content // new_line ( 'a' ) // repeat ( ' ' , self % indent ) else stringed = stringed // self % tag_content endif endif stringed = stringed // self % end_tag () endif endif endif endfunction stringify subroutine write_tag ( self , unit , is_indented , is_content_indented , form , end_record , only_start , only_content , only_end , & iostat , iomsg ) !< Write tag to unit file. class ( xml_tag ), intent ( in ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: unit !< File unit. logical , intent ( in ), optional :: is_indented !< Activate content indentation. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. character ( * ), intent ( in ), optional :: form !< Format. character ( * ), intent ( in ), optional :: end_record !< Ending record. logical , intent ( in ), optional :: only_start !< Write only start tag. logical , intent ( in ), optional :: only_content !< Write only content. logical , intent ( in ), optional :: only_end !< Write only end tag. integer ( I4P ), intent ( out ), optional :: iostat !< IO status. character ( * ), intent ( out ), optional :: iomsg !< IO message. type ( string ) :: form_ !< Format. type ( string ) :: end_record_ !< Ending record. integer ( I4P ) :: iostat_ !< IO status. character ( 500 ) :: iomsg_ !< IO message. form_ = 'UNFORMATTED' if ( present ( form )) then form_ = form form_ = form_ % upper () endif end_record_ = '' ; if ( present ( end_record )) end_record_ = end_record select case ( form_ % chars ()) case ( 'UNFORMATTED' ) write ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % stringify ( is_indented = is_indented , & is_content_indented = is_content_indented , & only_start = only_start , & only_content = only_content , & only_end = only_end ) // end_record_ case ( 'FORMATTED' ) write ( unit = unit , fmt = '(A)' , iostat = iostat_ , iomsg = iomsg_ ) self % stringify ( is_indented = is_indented , & is_content_indented = is_content_indented , & only_start = only_start , & only_content = only_content , & only_end = only_end ) // end_record_ endselect if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_tag ! private methods pure function is_attribute_present ( self , name ) result ( is_present ) !< Return .true. it the queried attribute name is defined, .false. otherwise. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Attribute name. logical :: is_present !< Inquire result. integer ( I4P ) :: a !< Counter. is_present = . false . if ( self % attributes_number > 0 ) then do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == name ) then is_present = . true . exit endif enddo endif endfunction is_attribute_present pure subroutine add_single_attribute ( self , attribute , sanitize_value ) !< Add one attribute name/value pair. !< !< @note Leading and trailing white spaces are trimmed out by attribute's name. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attribute ( 1 :) !< Attribute name/value pair [1:2]. logical , intent ( in ), optional :: sanitize_value !< Sanitize attribute value. type ( string ), allocatable :: new_attribute (:,:) !< Temporary storage for attributes. logical :: sanitize_value_ !< Sanitize attribute value. logical :: is_updated !< Flag to check if the attribute has been updeted. integer ( I4P ) :: a !< Counter. sanitize_value_ = . false . ; if ( present ( sanitize_value )) sanitize_value_ = sanitize_value if ( self % attributes_number > 0 ) then is_updated = . false . update_if_already_present : do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == attribute ( 1 )) then if ( sanitize_value_ ) then self % attribute ( 2 , a ) = trim ( adjustl ( attribute ( 2 ))) else self % attribute ( 2 , a ) = attribute ( 2 ) endif is_updated = . true . exit update_if_already_present endif enddo update_if_already_present if (. not . is_updated ) then allocate ( new_attribute ( 1 : 2 , 1 : self % attributes_number + 1 )) new_attribute ( 1 : 2 , 1 : self % attributes_number ) = self % attribute new_attribute ( 1 , self % attributes_number + 1 ) = trim ( adjustl ( attribute ( 1 ))) if ( sanitize_value_ ) then new_attribute ( 2 , self % attributes_number + 1 ) = trim ( adjustl ( attribute ( 2 ))) else new_attribute ( 2 , self % attributes_number + 1 ) = attribute ( 2 ) endif call move_alloc ( from = new_attribute , to = self % attribute ) self % attributes_number = self % attributes_number + 1 endif else call self % alloc_attributes ( Na = 1 ) self % attribute ( 1 , 1 ) = trim ( adjustl ( attribute ( 1 ))) if ( sanitize_value_ ) then self % attribute ( 2 , 1 ) = trim ( adjustl ( attribute ( 2 ))) else self % attribute ( 2 , 1 ) = attribute ( 2 ) endif endif endsubroutine add_single_attribute pure subroutine add_multiple_attributes ( self , attributes , sanitize_values ) !< Add list of attributes name/value pairs. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attributes ( 1 :, 1 :) !< Attribute name/value pair list [1:2,1:]. logical , intent ( in ), optional :: sanitize_values !< Sanitize attribute values. integer ( I4P ) :: a !< Counter. do a = 1 , size ( attributes , dim = 2 ) ! not efficient: many reallocation, but safe call self % add_single_attribute ( attribute = attributes ( 1 :, a ), sanitize_value = sanitize_values ) enddo endsubroutine add_multiple_attributes pure subroutine add_stream_attributes ( self , attributes_stream , sanitize_values ) !< Add list of attributes name/value pairs passed as stream. !< !< @note The character `=` cannot compare into the attributes names of values. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attributes_stream !< Attribute name/value pair list passed as stream. logical , intent ( in ), optional :: sanitize_values !< Sanitize attribute values. type ( string ) :: attributes_string !< Attribute name/value pair list as string. type ( string ) :: tokens ( 1 : 3 ) !< Attributes tokenized by `=`. type ( string ) :: attribute ( 1 : 2 ) !< Attribute name/value pair. logical :: continue_to_parse !< Sentinel to stop attributes stream parsing. integer ( I4P ) :: max_chars !< Counter. attributes_string = attributes_stream continue_to_parse = . true . do while ( continue_to_parse ) tokens = attributes_string % partition ( sep = '=' ) attribute ( 1 ) = trim ( adjustl ( tokens ( 1 ))) if ( attribute ( 1 ) /= '' ) then tokens ( 3 ) = tokens ( 3 )% slice ( istart = tokens ( 3 )% index ( '\"' ) + 1 , iend = tokens ( 3 )% len ()) attribute ( 2 ) = tokens ( 3 )% slice ( istart = 1 , iend = tokens ( 3 )% index ( '\"' ) - 1 ) tokens ( 3 ) = tokens ( 3 )% slice ( istart = tokens ( 3 )% index ( '\"' ) + 1 , iend = tokens ( 3 )% len ()) max_chars = max ( attribute ( 1 )% len (), attribute ( 2 )% len ()) attribute ( 1 ) = attribute ( 1 )% fill ( width = max_chars , right = . true ., filling_char = ' ' ) attribute ( 2 ) = attribute ( 2 )% fill ( width = max_chars , right = . true ., filling_char = ' ' ) call self % add_single_attribute ( attribute = [ attribute ( 1 ) // '' , attribute ( 2 ) // '' ], sanitize_value = sanitize_values ) if ( tokens ( 3 )% index ( '=' ) > 0 ) then attributes_string = tokens ( 3 ) else continue_to_parse = . false . endif else continue_to_parse = . false . endif enddo endsubroutine add_stream_attributes elemental subroutine alloc_attributes ( self , Na ) !< Allocate (prepare for filling) dynamic memory of attributes. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: Na !< Number of attributes. if ( allocated ( self % attribute )) then call self % attribute % free deallocate ( self % attribute ) endif allocate ( self % attribute ( 1 : 2 , 1 : Na )) self % attributes_number = Na endsubroutine alloc_attributes pure subroutine delete_content ( self ) !< Delete tag content. class ( xml_tag ), intent ( inout ) :: self !< XML tag. call self % tag_content % free endsubroutine delete_content pure subroutine delete_single_attribute ( self , name ) !< Delete one attribute name/value pair. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Attribute name. type ( string ), allocatable :: new_attribute (:,:) !< Temporary storage for attributes. integer ( I4P ) :: a !< Counter. if ( self % attributes_number > 0 ) then search_tag : do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == name ) then if ( self % attributes_number > 1 ) then allocate ( new_attribute ( 1 : 2 , 1 : self % attributes_number - 1 )) if ( a == 1 ) then new_attribute (:, a :) = self % attribute (:, a + 1 :) elseif ( a == self % attributes_number ) then new_attribute (:, : a - 1 ) = self % attribute (:, : a - 1 ) else new_attribute (:, : a - 1 ) = self % attribute (:, : a - 1 ) new_attribute (:, a :) = self % attribute (:, a + 1 :) endif call move_alloc ( from = new_attribute , to = self % attribute ) else call self % attribute % free deallocate ( self % attribute ) endif self % attributes_number = self % attributes_number - 1 exit search_tag endif enddo search_tag endif endsubroutine delete_single_attribute pure subroutine delete_multiple_attributes ( self , name ) !< Delete list of attributes name/value pairs. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: name ( 1 :) !< Attributes names. integer ( I4P ) :: a !< Counter. do a = 1 , size ( name , dim = 1 ) call self % delete_single_attribute ( name = name ( a )) enddo endsubroutine delete_multiple_attributes elemental subroutine get ( self , source ) !< Get the tag content and attributes from source after tag_name and attributes names have been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. call self % get_value ( source = source ) call self % get_attributes ( source = source ) ! call self%get_nested() endsubroutine get elemental subroutine get_attributes ( self , source ) !< Get the attributes values from source after tag_name and attributes names have been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: a !< Counter. integer :: c1 !< Counter. integer :: c2 !< Counter. if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then if ( self % attributes_number > 0 ) then ! parsing attributes do a = 1 , self % attributes_number c1 = index ( string = source , substring = self % attribute ( 1 , a ) // '=\"' ) + self % attribute ( 1 , a )% len () + 2 if ( c1 > self % attribute ( 1 , a )% len () + 2 ) then c2 = index ( string = source ( c1 :), substring = '\"' ) if ( c2 > 0 ) then self % attribute ( 2 , a ) = source ( c1 : c1 + c2 - 2 ) else call self % attribute ( 2 , a )% free endif else call self % attribute ( 2 , a )% free endif enddo endif endif endsubroutine get_attributes elemental subroutine get_value ( self , source ) !< Get the tag value from source after tag_name has been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: c1 !< Counter. integer :: c2 !< Counter. call self % tag_content % free self % is_self_closing = . false . if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then c2 = index ( string = source , substring = '</' // self % tag_name // '>' ) if ( c2 > 0 ) then ! parsing tag value c1 = index ( string = source , substring = '>' ) if ( c1 + 1 < c2 - 1 ) self % tag_content = source ( c1 + 1 : c2 - 1 ) else self % is_self_closing = . true . endif endif endsubroutine get_value elemental subroutine parse_attributes_names ( self , source ) !< Parse the tag attributes names contained into a string. !< !< Valid syntax is: !< + `att1=\"att1 val\" att2=\"att2 val\"...` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. character ( len = :), allocatable :: att !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: Na !< Counter. Na = 0 c = 1 Att_Count : do while ( c <= len ( source )) if ( source ( c : c ) == '=' ) Na = Na + 1 c = c + 1 enddo Att_Count if ( Na > 0 ) then call self % alloc_attributes ( Na = Na ) c = index ( string = source , substring = ' ' ) att = source ( c :) c = 1 a = 1 Att_Search : do while ( c <= len ( att )) if ( att ( c : c ) == '=' ) then s = max ( 0 , index ( string = att , substring = ' ' )) self % attribute ( 1 , a ) = trim ( adjustl ( att ( s + 1 : c - 1 ))) att = att ( c + 1 :) c = 1 a = a + 1 endif c = c + 1 enddo Att_Search endif endsubroutine parse_attributes_names elemental subroutine parse_tag_name ( self , source , tstart , tend ) !< Parse the tag name contained into a string. !< !< It is assumed that the first tag contained into the source is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. integer ( I4P ) :: tstartd !< Starting index of tag inside the source. integer ( I4P ) :: tendd !< Ending index of tag inside the source. character ( len = 1 ) :: c1 !< Dummy string for parsing file. character ( len = :), allocatable :: c2 !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. tstartd = 0 tendd = 0 c = 1 Tag_Search : do while ( c <= len ( source )) c1 = source ( c : c ) if ( c1 == '<' ) then tstartd = c c2 = c1 Tag_Name : do while ( c < len ( source )) c = c + 1 ; c1 = source ( c : c ) c2 = c2 // c1 if ( c1 == '>' ) then tendd = c exit Tag_Name endif enddo Tag_Name s = index ( string = c2 , substring = ' ' ) if ( s > 0 ) then ! there are attributes self % tag_name = c2 ( 2 : s - 1 ) else if ( index ( string = c2 , substring = '/>' ) > 0 ) then ! self closing tag self % tag_name = c2 ( 2 : len ( c2 ) - 2 ) else self % tag_name = c2 ( 2 : len ( c2 ) - 1 ) endif endif exit Tag_Search endif c = c + 1 enddo Tag_Search if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd endsubroutine parse_tag_name elemental subroutine search ( self , tag_name , source , tstart , tend ) !< Search tag named *tag_name* into a string and, in case it is found, store into self. !< !< @note If *tag_name* is not found, self is returned empty. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: tag_name !< Searched tag name. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. type ( xml_tag ) :: tag !< Dummy XML tag. integer ( I4P ) :: tstart_ !< Starting index of tag inside the source, local variable. integer ( I4P ) :: tend_ !< Ending index of tag inside the source, local variable. logical :: found !< Flag for inquiring search result. integer ( I4P ) :: tstart_c !< Starting index of tag inside the current slice of source. integer ( I4P ) :: tend_c !< Starting index of tag inside the current slice of source. integer ( I4P ) :: i call self % free self % tag_name = tag_name tstart_ = 1 tend_ = 0 found = . false . tstart_c = 0 tend_c = 0 Tag_Search : do call tag % parse ( source = source ( tend_ + 1 :), tstart = tstart_c , tend = tend_c ) tstart_ = tstart_ + tend_ tend_ = tend_ + tend_c if ( tstart_c == 0. and . tend_c == 0 ) then exit Tag_Search ! no tag found else if ( tag % tag_name % is_allocated ()) then if ( tag % tag_name == self % tag_name ) then found = . true . endif endif endif if ( found ) exit Tag_Search enddo Tag_Search if ( found ) then self = tag else call self % free endif if ( present ( tstart )) tstart = tstart_ if ( present ( tend )) tend = tend_ endsubroutine search ! assignment (=) elemental subroutine assign_tag ( lhs , rhs ) !< Assignment between two tags. class ( xml_tag ), intent ( inout ) :: lhs !< Left hand side. type ( xml_tag ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: a !< Counter. call lhs % free if ( rhs % tag_name % is_allocated ()) lhs % tag_name = rhs % tag_name if ( rhs % tag_content % is_allocated ()) lhs % tag_content = rhs % tag_content if ( rhs % attributes_number > 0 ) then allocate ( lhs % attribute ( 1 : 2 , 1 : rhs % attributes_number )) do a = 1 , rhs % attributes_number lhs % attribute ( 1 : 2 , a ) = rhs % attribute ( 1 : 2 , a ) enddo endif lhs % attributes_number = rhs % attributes_number lhs % indent = rhs % indent lhs % is_self_closing = rhs % is_self_closing endsubroutine assign_tag ! finalize elemental subroutine finalize ( tag ) !< Free dynamic memory when finalizing. type ( xml_tag ), intent ( inout ) :: tag !< XML tag. call tag % free endsubroutine finalize endmodule foxy_xml_tag","tags":"","loc":"sourcefile/foxy_xml_tag.f90.html"},{"title":"foxy.f90 – FoXy","text":"Contents Modules foxy Source Code foxy.f90 Source Code !< FoXy, Fortran XML parser for poor people module foxy !< FoXy, Fortran XML parser for poor people use foxy_xml_file , only : xml_file use foxy_xml_tag , only : xml_tag use penf implicit none private public :: I1P , I2P , I4P , I8P , R4P , R8P public :: xml_file public :: xml_tag endmodule foxy","tags":"","loc":"sourcefile/foxy.f90.html"},{"title":"concatenation.f90 – FoXy","text":"Contents Programs concatenation Source Code concatenation.f90 Source Code !< StringiFor `concatenation` test. program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' test_passed ( 1 ) = astring // acharacter == 'Hello World!' write ( stdout , \"(A)\" ) astring // acharacter test_passed ( 2 ) = acharacter // astring == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) acharacter // astring test_passed ( 3 ) = astring // anotherstring == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter test_passed ( 4 ) = yetanotherstring % chars () == 'Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring test_passed ( 5 ) = yetanotherstring % chars () == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring test_passed ( 6 ) = yetanotherstring % chars () == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"sourcefile/concatenation.f90.html"},{"title":"split.f90 – FoXy","text":"Contents Programs split Source Code split.f90 Source Code !< StringiFor `split` test. program split !< StringiFor `split` test. use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. logical :: test_passed ( 12 ) !< List of passed tests. integer :: s !< Counter. test_passed = . false . astring = '+ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello ' // new_line ( 'a' ) // 'World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"new_line\"' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"default\" (namely space)' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = '+ab-' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 6 ) = ( strings ( 1 ) // '' == 'ab-' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = '+ab-' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"-\"' call astring % split ( tokens = strings , sep = '-' ) test_passed ( 7 ) = ( strings ( 1 ) // '' == '+ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = '+ab-+cd-' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 8 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-+cd-+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 9 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = '+ab-+cd-+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 10 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = '1-2-3-4-5-6-7-8' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"-\" in max 3 or 4 tokens' call astring % split ( tokens = strings , sep = '-' , max_tokens = 3 ) test_passed ( 11 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4-5-6-7-8' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = '-1-2-3-4-5-6-7-8-' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"-\" in chunks of 3' call astring % split_chunked ( tokens = strings , sep = '-' , chunks = 3 ) test_passed ( 12 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4' . and . & strings ( 5 ) // '' == '5' . and . strings ( 6 ) // '' == '6' . and . strings ( 7 ) // '' == '7' . and . strings ( 8 ) // '' == '8' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram split","tags":"","loc":"sourcefile/split.f90.html"},{"title":"read_file.f90 – FoXy","text":"Contents Programs read_file Source Code read_file.f90 Source Code !< StringiFor `read_file` test. program read_file !< StringiFor `read_file` test. use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : read_file_standalone => read_file , string implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 17 ) !< List of passed tests. test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) write ( stdout , \"(A)\" ) \"TBP read_file\" call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_file\" call read_file_standalone ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) write ( stdout , \"(A)\" ) \"TBP read_file unformatted\" call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_file unformatted\" call read_file_standalone ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat ) test_passed ( 17 ) = ( iostat /= 0 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Test iostat read from missing file passed? ' , test_passed ( 17 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram read_file","tags":"","loc":"sourcefile/read_file.f90.html"},{"title":"free.f90 – FoXy","text":"Contents Programs free Source Code free.f90 Source Code !< StringiFor `free` test. program free !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `free` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % is_allocated (). eqv .. true . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () call astring % free test_passed ( 2 ) = astring % is_allocated (). eqv .. false . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram free","tags":"","loc":"sourcefile/free.f90.html"},{"title":"replace.f90 – FoXy","text":"Contents Programs replace Source Code replace.f90 Source Code !< StringiFor `replace` test. program replace !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `replace` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'When YOU are sad YOU should think to me :-)' write ( stdout , \"(A)\" ) 'Original:                                 \"' // astring // '\"' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace \"YOU\" with \"THEY\":                \"' // astring % replace ( old = 'YOU' , new = 'THEY' ) // '\"' test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace only the first \"YOU\" with \"THEY\": \"' // astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '\"' astring = repeat ( new_line ( 'a' ) // 'abcd' , 20 ) write ( stdout , \"(A)\" ) 'Original new_line test: \"' // astring // '\"' astring = astring % replace ( old = new_line ( 'a' ), new = '|cr|' ) astring = astring % replace ( old = '|cr|' , new = new_line ( 'a' ) // '    ' ) test_passed ( 3 ) = ( astring // '' == repeat ( new_line ( 'a' ) // '    ' // 'abcd' , 20 )) write ( stdout , \"(A)\" ) 'Replace \"new_line\" with \"new_line+indent\": \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram replace","tags":"","loc":"sourcefile/replace.f90.html"},{"title":"glob.f90 – FoXy","text":"Contents Programs glob Source Code glob.f90 Source Code !< StringiFor `glob` test. program glob !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `glob` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: alist_str (:) !< A list (string). character ( len = :), allocatable :: alist_chr (:) !< A list (character). integer , parameter :: Nf = 5 !< Maximum number of files. character ( 14 ) :: files ( 1 : Nf ) !< Files list. integer :: file_unit !< File unit. integer :: f !< Counter. integer :: ff !< Counter. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) print * , 'Create file ' // files ( f ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo if ( size ( alist_str , dim = 1 ) /= Nf ) error stop 'error: glob search failed' if ( size ( alist_chr , dim = 1 ) /= Nf ) error stop 'error: glob search failed' print * , ' Files found by glob (string output)' outer_str : do f = 1 , size ( alist_str , dim = 1 ) print * , alist_str ( f )% chars () do ff = 1 , Nf test_passed ( 1 ) = alist_str ( f ) == files ( ff ) if ( test_passed ( 1 )) cycle outer_str enddo enddo outer_str print * , ' Files found by glob (character output)' outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) print * , alist_chr ( f ) do ff = 1 , Nf test_passed ( 2 ) = alist_chr ( f ) == files ( ff ) if ( test_passed ( 2 )) cycle outer_chr enddo enddo outer_chr write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) !----------------------------------------------------------------------------------------------------------------------------------- endprogram glob","tags":"","loc":"sourcefile/glob.f90.html"},{"title":"startcase.f90 – FoXy","text":"Contents Programs startcase Source Code startcase.f90 Source Code !< StringiFor `startcase` test. program startcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `startcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % startcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram startcase","tags":"","loc":"sourcefile/startcase.f90.html"},{"title":"swapcase.f90 – FoXy","text":"Contents Programs swapcase Source Code swapcase.f90 Source Code !< StringiFor `swapcase` test. program swapcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `swapcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' write ( stdout , \"(A,L1)\" ) 'Swapcase: \"' // astring % swapcase () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram swapcase","tags":"","loc":"sourcefile/swapcase.f90.html"},{"title":"strim.f90 – FoXy","text":"Contents Programs strim Source Code strim.f90 Source Code !< StringiFor `strim` test. program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % trim () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Trimmed:  \"' // astring % trim () // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = trim ( astring ) // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Trimmed (builtin):  \"' // trim ( astring ) // '\", is correct? ' , test_passed ( 2 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"sourcefile/strim.f90.html"},{"title":"srepeat.f90 – FoXy","text":"Contents Programs srepeat Source Code srepeat.f90 Source Code !< StringiFor `srepeat` test. program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'x' test_passed ( 1 ) = astring % repeat ( rstring = 'x' , ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat x 5 times: \"' // astring % repeat ( rstring = 'x' , ncopies = 5 ) // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % repeat ( ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat (self) x 5 times: \"' // astring % repeat ( ncopies = 5 ) // '\", is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = repeat ( astring , 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat (builtin) x 5 times: \"' // repeat ( astring , 5 ) // '\", is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"sourcefile/srepeat.f90.html"},{"title":"escape.f90 – FoXy","text":"Contents Programs escape Source Code escape.f90 Source Code !< StringiFor `escape` test. program escape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `escape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\s \\d+\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ') write(stdout, \"(A)\") ' Escaped : \"'//astring%escape(to_escape='\\')//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram escape","tags":"","loc":"sourcefile/escape.f90.html"},{"title":"fill.f90 – FoXy","text":"Contents Programs fill Source Code fill.f90 Source Code !< StringiFor `fill` test. program fill !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `fill` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40): \"' // astring % fill ( width = 40 ) // '\"' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=50): \"' // astring % fill ( width = 50 ) // '\"' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' write ( stdout , \"(A)\" ) 'Fill (w=50, right): \"' // astring % fill ( width = 50 , right = . true .) // '\"' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40, fc=*): \"' // astring % fill ( width = 40 , filling_char = '*' ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram fill","tags":"","loc":"sourcefile/fill.f90.html"},{"title":"read_lines.f90 – FoXy","text":"Contents Programs read_lines Source Code read_lines.f90 Source Code !< StringiFor `read_lines` test. program read_lines !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_lines` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : read_lines_standalone => read_lines , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () write ( stdout , \"(A)\" ) \"TBP read_lines\" call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_lines\" call read_lines_standalone ( unit = scratch , lines = strings , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat ). and . iostat /= iostat_end ) write ( stdout , \"(A)\" ) iomsg test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) write ( stdout , \"(A)\" ) \"TBP read_lines unformatted\" call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_lines unformatted\" call read_lines_standalone ( unit = scratch , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat ). and . iostat /= iostat_end ) write ( stdout , \"(A)\" ) iomsg test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_lines","tags":"","loc":"sourcefile/read_lines.f90.html"},{"title":"extension.f90 – FoXy","text":"Contents Programs extension Source Code extension.f90 Source Code !< StringiFor `extension` test. program extension !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `extension` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % extension () // '' == '.bz2' ) write ( stdout , \"(A)\" ) 'Extension: \"' // astring % extension () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram extension","tags":"","loc":"sourcefile/extension.f90.html"},{"title":"read_line.f90 – FoXy","text":"Contents Programs read_line Source Code read_line.f90 Source Code !< StringiFor `read_line` test. program read_line !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_line` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: line ( 3 ) !< A set of strings. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' write ( stdout , \"(A)\" ) ' Formatted read' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then write ( stdout , \"(A)\" ) iomsg exit else test_passed ( l ) = ( astring == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // astring // '\", is correct? ' , test_passed ( l ) endif enddo close ( scratch ) write ( stdout , \"(A)\" ) ' Unformatted read' open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then write ( stdout , \"(A)\" ) iomsg exit else test_passed ( l + 3 ) = ( astring == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // astring // '\", is correct? ' , test_passed ( l + 3 ) endif enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_line","tags":"","loc":"sourcefile/read_line.f90.html"},{"title":"slice.f90 – FoXy","text":"Contents Programs slice Source Code slice.f90 Source Code !< StringiFor `slice` test. program slice !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slice` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % slice ( 11 , 25 ) == 'Brown fox Jumps' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % slice ( 11 , 25 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slice","tags":"","loc":"sourcefile/slice.f90.html"},{"title":"sindex.f90 – FoXy","text":"Contents Programs sindex Source Code sindex.f90 Source Code !< StringiFor `sindex` test. program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % index ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % index ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex back call result: ' , i , ' is correct? ' , test_passed ( 2 ) i = index ( astring , substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index basic call result: ' , i , ' is correct? ' , test_passed ( 3 ) i = index ( astring , substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 4 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex back call result: ' , i , ' is correct? ' , test_passed ( 4 ) astring = anothercharacter i = index ( acharacter , substring = astring ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 5 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index (inverted) basic call result: ' , i , ' is correct? ' , test_passed ( 5 ) astring = anothercharacter i = index ( acharacter , substring = astring , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 6 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index (inverted) back call result: ' , i , ' is correct? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"sourcefile/sindex.f90.html"},{"title":"scount.f90 – FoXy","text":"Contents Programs count_string Source Code scount.f90 Source Code !< StringiFor `count_string` test. program count_string !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `count_string` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer :: No !< Number of occurences. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' No = astring % count ( substring = ' ' , ignore_isolated = . true .) test_passed ( 1 ) = No == 3 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \" \" ignore isolated: \"' , No , '\", is correct? ' , test_passed ( 1 ) No = astring % count ( substring = ' ' ) test_passed ( 2 ) = No == 4 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \" \": \"' , No , '\", is correct? ' , test_passed ( 2 ) No = astring % count ( substring = 'l' ) test_passed ( 3 ) = No == 3 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \"l\": \"' , No , '\", is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram count_string","tags":"","loc":"sourcefile/scount.f90.html"},{"title":"is_integer.f90 – FoXy","text":"Contents Programs is_integer Source Code is_integer.f90 Source Code !< StringiFor `is_integer` test. program is_integer !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_integer` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_integer","tags":"","loc":"sourcefile/is_integer.f90.html"},{"title":"is_number.f90 – FoXy","text":"Contents Programs is_number Source Code is_number.f90 Source Code !< StringiFor `is_number` test. program is_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_number","tags":"","loc":"sourcefile/is_number.f90.html"},{"title":"join.f90 – FoXy","text":"Contents Programs join Source Code join.f90 Source Code !< StringiFor `join` test. program join !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `join` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. character ( 5 ) :: characters ( 3 ) !< A set of characters. logical :: test_passed ( 11 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = strings ) // '\"' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = characters ) // '\"' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 7 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 8 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 9 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 10 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo astring = '_' write ( stdout , \"(A)\" ) 'join (sep by astring) \"' // astring % join ( array = characters ) // '\"' test_passed ( 11 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram join","tags":"","loc":"sourcefile/join.f90.html"},{"title":"upper_lower.f90 – FoXy","text":"Contents Programs upper_lower Source Code upper_lower.f90 Source Code !< StringiFor `upper_lower` test. program upper_lower !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `upper_lower` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 : 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' test_passed ( 2 ) = astring % lower () // '' == 'hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'UPPER:    \"' // astring % upper () // '\". Is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'lower:    \"' // astring % lower () // '\". Is correct? ' , test_passed ( 2 ) astring = ' Hello World' test_passed ( 3 ) = astring % is_upper (). eqv .. false . test_passed ( 4 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 4 ) astring = ' HELLO WORLD' test_passed ( 5 ) = astring % is_upper (). eqv .. true . test_passed ( 6 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 6 ) astring = ' hello world' test_passed ( 7 ) = astring % is_upper (). eqv .. false . test_passed ( 8 ) = astring % is_lower (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 8 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram upper_lower","tags":"","loc":"sourcefile/upper_lower.f90.html"},{"title":"search.f90 – FoXy","text":"Contents Programs search Source Code search.f90 Source Code !< StringiFor `search` test. program search !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `search` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. integer :: istart !< Start index of searched tag. integer :: iend !< End index of searched tag. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 1 ) astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 2 ) call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // anotherstring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 3 ) call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 4 ) acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram search","tags":"","loc":"sourcefile/search.f90.html"},{"title":"tempname.f90 – FoXy","text":"Contents Programs tempname Source Code tempname.f90 Source Code !< StringiFor `tempname` test. program tempname !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `tempname` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: tmpname !< A temporary name. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 1 )) test_passed ( 1 ) = . not . test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'tempname: \"' // tmpname // '\", is safe? ' , test_passed ( 1 ) tmpname = astring % tempname ( is_file = . false .) inquire ( file = tmpname , exist = test_passed ( 2 )) test_passed ( 2 ) = . not . test_passed ( 2 ) write ( stdout , \"(A,L1)\" ) 'tempname: \"' // tmpname // '\", is safe? ' , test_passed ( 2 ) tmpname = astring % tempname ( path = './' ) inquire ( file = tmpname , exist = test_passed ( 3 )) test_passed ( 3 ) = . not . test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) 'tempname: \"' // tmpname // '\", is safe? ' , test_passed ( 3 ) astring = 'me-' tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 4 )) test_passed ( 4 ) = . not . test_passed ( 4 ) write ( stdout , \"(A,L1)\" ) 'tempname: \"' // tmpname // '\", is safe? ' , test_passed ( 4 ) tmpname = astring % tempname ( prefix = 'you-' ) inquire ( file = tmpname , exist = test_passed ( 5 )) test_passed ( 5 ) = . not . test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) 'tempname: \"' // tmpname // '\", is safe? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) !----------------------------------------------------------------------------------------------------------------------------------- endprogram tempname","tags":"","loc":"sourcefile/tempname.f90.html"},{"title":"equal.f90 – FoXy","text":"Contents Programs equal Source Code equal.f90 Source Code !< StringiFor `equal` test. program equal !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `equal` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  one ' anotherstring = 'two' acharacter = 'three' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring == acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter == astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '==' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'the same ' anotherstring = 'the same ' acharacter = 'the same ' test_passed ( 4 ) = (( astring == anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring == acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter == astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '==' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram equal","tags":"","loc":"sourcefile/equal.f90.html"},{"title":"io_listdirected.F90 – FoXy","text":"Contents Programs io_formatted Source Code io_listdirected.F90 Source Code !< StringiFor `io_formatted` test. program io_formatted !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_formatted` test. !< !< @bug Does not work for undelimited with terminators: ifort 16.0.3 !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , IOSTAT_EOR use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none #ifndef __GFORTRAN__ type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. #endif logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . #ifndef __GFORTRAN__ acharacter = 'NoSpaces' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = ( astring == 'NoSpaces' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 1 ) if (. not . test_passed ( 1 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = 'No quotes' ! read(acharacter, *, iostat=iostat, iomsg=iomsg) astring ! test_passed(2) = (astring == 'No') test_passed ( 2 ) = . true . write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 2 ) if (. not . test_passed ( 2 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = '\"Has quotes\"' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 3 ) = ( astring == 'Has quotes' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 3 ) if (. not . test_passed ( 3 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = '\"Internal \"\" quotes\"' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 4 ) = ( astring == 'Internal \" quotes' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 4 ) if (. not . test_passed ( 4 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif #else ! GNU gfortran does not support defined IO test_passed = . true . #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_formatted","tags":"","loc":"sourcefile/io_listdirected.f90.html"},{"title":"sadjustlr.f90 – FoXy","text":"Contents Programs sadjustlr Source Code sadjustlr.f90 Source Code !< StringiFor `sadjustlr` test. program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % adjustl () // '' == 'Hello World!   ' write ( stdout , \"(A,L1)\" ) 'AdjustL:  \"' // astring % adjustl () // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = adjustl ( astring ) // '' == 'Hello World!   ' write ( stdout , \"(A,L1)\" ) 'AdjustL (builtin):  \"' // adjustl ( astring ) // '\", is correct? ' , test_passed ( 2 ) astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 3 ) = astring % adjustr () // '' == '   Hello World!' write ( stdout , \"(A,L1)\" ) 'AdjustR:  \"' // astring % adjustr () // '\", is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = adjustr ( astring ) // '' == '   Hello World!' write ( stdout , \"(A,L1)\" ) 'AdjustR (builtin):  \"' // adjustr ( astring ) // '\", is correct? ' , test_passed ( 4 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"sourcefile/sadjustlr.f90.html"},{"title":"sscan.f90 – FoXy","text":"Contents Programs sscan Source Code sscan.f90 Source Code !< StringiFor `sscan` test. program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter anotherstring = anothercharacter i = astring % scan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % scan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) i = scan ( astring , set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 3 ) i = scan ( acharacter , set = anotherstring , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 4 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 4 ) i = scan ( astring , set = anotherstring , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 5 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"sourcefile/sscan.f90.html"},{"title":"is_digit.f90 – FoXy","text":"Contents Programs is_digit Source Code is_digit.f90 Source Code !< StringiFor `is_digit` test. program is_digit !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_digit` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_digit","tags":"","loc":"sourcefile/is_digit.f90.html"},{"title":"io_basic.F90 – FoXy","text":"Contents Programs io_basic Source Code io_basic.F90 Source Code !< StringiFor `io_basic` test. program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none #ifndef __GFORTRAN__ type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. #endif logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . #ifndef __GFORTRAN__ astring = 'Hello World!' acharacter = 'New Hello World!' write ( stdout , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = iostat == 0 if ( iostat /= 0 ) print \"(A)\" , iomsg read ( acharacter , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 2 ) = iostat == 0 if ( iostat /= 0 ) print \"(A)\" , iomsg print \"(DT)\" , astring #else ! GNU gfortran does not support defined IO test_passed = . true . #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"sourcefile/io_basic.f90.html"},{"title":"basename_dir.f90 – FoXy","text":"Contents Programs basename_dir Source Code basename_dir.f90 Source Code !< StringiFor `basename_dir` test. program basename_dir !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `basename_dir` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:                  \"' // astring // '\"' test_passed ( 1 ) = ( astring % basedir () // '' == '/bar' ) write ( stdout , \"(A)\" ) 'Basedir:                   \"' // astring % basedir () // '\"' test_passed ( 2 ) = ( astring % basename () // '' == 'foo.tar.bz2' ) write ( stdout , \"(A)\" ) 'Basename:                  \"' // astring % basename () // '\"' test_passed ( 3 ) = ( astring % basename ( extension = '.tar' ) // '' == 'foo' ) write ( stdout , \"(A)\" ) 'Basename (extension):      \"' // astring % basename ( extension = '.tar' ) // '\"' test_passed ( 4 ) = ( astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' ) write ( stdout , \"(A)\" ) 'Basename (last extension): \"' // astring % basename ( strip_last_extension = . true .) // '\"' astring = '\\bar\\foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original (\\ sep):          \"' // astring // '\"' test_passed ( 5 ) = ( astring % basedir ( sep = '\\')//''==' \\ bar ') write(stdout, \"(A)\") ' Basedir : \"'//astring%basedir(sep='\\')//'\" ' test_passed(6) = (astring%basename(sep=' \\ ')//''==' foo . tar . bz2 ') write(stdout, \"(A)\") ' Basename : \"'//astring%basename(sep='\\')//'\" ' test_passed(7) = (astring%basename(sep=' \\ ', extension=' . tar ')//''==' foo ') write(stdout, \"(A)\") ' Basename ( extension ): \"'//astring%basename(sep='\\', extension='.tar')//'\" ' test_passed(8) = (astring%basename(sep=' \\ ', strip_last_extension=.true.)//''==' foo . tar ') write(stdout, \"(A)\") ' Basename ( last extension ): \"'//astring%basename(sep='\\', strip_last_extension=.true.)//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram basename_dir","tags":"","loc":"sourcefile/basename_dir.f90.html"},{"title":"slen.f90 – FoXy","text":"Contents Programs slen Source Code slen.f90 Source Code !< StringiFor `slen` test. program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % len () == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Slen: ' , astring % len (), ' is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % len_trim () == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Slen_trim: ' , astring % len_trim (), ' is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = len ( astring ) == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Len: ' , len ( astring ), ' is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = len_trim ( astring ) == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Len_trim: ' , len_trim ( astring ), ' is correct? ' , test_passed ( 4 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"sourcefile/slen.f90.html"},{"title":"greater_than.f90 – FoXy","text":"Contents Programs greater_than Source Code greater_than.f90 Source Code !< StringiFor `greater_than` test. program greater_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `greater_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring > acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter > astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring > anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring > acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter > astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram greater_than","tags":"","loc":"sourcefile/greater_than.f90.html"},{"title":"greater_equal_than.f90 – FoXy","text":"Contents Programs greater_equal_than Source Code greater_equal_than.f90 Source Code !< StringiFor `greater_equal_than` test. program greater_equal_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `greater_equal_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 9 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring >= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter >= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring >= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring >= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter >= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 6 ) astring = 'ONE' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 7 ) = (( astring >= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 7 ) test_passed ( 8 ) = (( astring >= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 8 ) test_passed ( 9 ) = (( acharacter >= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 9 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram greater_equal_than","tags":"","loc":"sourcefile/greater_equal_than.f90.html"},{"title":"to_number.f90 – FoXy","text":"Contents Programs to_number Source Code to_number.f90 Source Code !< StringiFor `to_number` test. program to_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `to_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: integer_I1P !< A integer. integer ( I1P ) :: integer_I1P_ !< A integer. integer ( I2P ) :: integer_I2P !< A integer. integer ( I2P ) :: integer_I2P_ !< A integer. integer ( I4P ) :: integer_I4P !< A integer. integer ( I4P ) :: integer_I4P_ !< A integer. integer ( I8P ) :: integer_I8P !< A integer. integer ( I8P ) :: integer_I8P_ !< A integer. real ( R4P ) :: real_R4P !< A real. real ( R4P ) :: real_R4P_ !< A real. real ( R8P ) :: real_R8P !< A real. real ( R8P ) :: real_R8P_ !< A real. real ( R16P ) :: real_R16P !< A real. real ( R16P ) :: real_R16P_ !< A real. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '127' integer_I1P = astring % to_number ( kind = 1_I1P ) integer_I1P_ = 127_I1P test_passed ( 1 ) = integer_I1P == integer_I1P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I4,A)\" ) 'To number: \"' , integer_I1P , '\"' astring = '32767' integer_I2P = astring % to_number ( kind = 1_I2P ) integer_I2P_ = 32767_I2P test_passed ( 2 ) = integer_I2P == integer_I2P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I6,A)\" ) 'To number: \"' , integer_I2P , '\"' astring = '2147483647' integer_I4P = astring % to_number ( kind = 1_I4P ) integer_I4P_ = 2147483647_I4P test_passed ( 3 ) = integer_I4P == integer_I4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I11,A)\" ) 'To number: \"' , integer_I4P , '\"' astring = '-9223372036854775807' integer_I8P = astring % to_number ( kind = 1_I8P ) integer_I8P_ = - 9223372036854775807_I8P test_passed ( 4 ) = integer_I8P == integer_I8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I20,A)\" ) 'To number: \"' , integer_I8P , '\"' astring = '3.4e9' real_R4P = astring % to_number ( kind = 1._R4P ) real_R4P_ = 3.4e9_R4P test_passed ( 5 ) = real_R4P == real_R4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E13.6,A)\" ) 'To number: \"' , real_R4P , '\"' astring = '-13.4345345e21' real_R8P = astring % to_number ( kind = 1._R8P ) real_R8P_ = - 1 3.4345345e21_R8P test_passed ( 6 ) = real_R8P == real_R8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E23.15,A)\" ) 'To number: \"' , real_R8P , '\"' astring = '1.1e200' real_R16P = astring % to_number ( kind = 1._R16P ) real_R16P_ = 1.1e200_R16P test_passed ( 7 ) = real_R16P == real_R16P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E42.33,A)\" ) 'To number: \"' , real_R16P , '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram to_number","tags":"","loc":"sourcefile/to_number.f90.html"},{"title":"lower_equal_than.f90 – FoXy","text":"Contents Programs lower_equal_than Source Code lower_equal_than.f90 Source Code !< StringiFor `lower_equal_than` test. program lower_equal_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `lower_equal_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 9 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring <= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring <= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring <= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter <= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 6 ) astring = 'ONE' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 7 ) = (( astring <= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 7 ) test_passed ( 8 ) = (( astring <= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 8 ) test_passed ( 9 ) = (( acharacter <= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 9 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram lower_equal_than","tags":"","loc":"sourcefile/lower_equal_than.f90.html"},{"title":"snakecase.f90 – FoXy","text":"Contents Programs snakecase Source Code snakecase.f90 Source Code !< StringiFor `snakecase` test. program snakecase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `snakecase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % snakecase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram snakecase","tags":"","loc":"sourcefile/snakecase.f90.html"},{"title":"stringifor_test_assignments.f90 – FoXy","text":"Contents Programs stringifor_test_assignments Source Code stringifor_test_assignments.f90 Source Code !< StringiFor `assignments` test. program stringifor_test_assignments !< StringiFor `assignments` test. use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: ainteger_I1P !< A integer (I1P). integer ( I2P ) :: ainteger_I2P !< A integer (I2P). integer ( I4P ) :: ainteger_I4P !< A integer (I4P). integer ( I8P ) :: ainteger_I8P !< A integer (I8P). real ( R4P ) :: areal_R4P !< A real (R4P). real ( R8P ) :: areal_R8P !< A real (R8P). real ( R16P ) :: areal_R16P !< A real (R16P). logical :: test_passed ( 7 ) !< List of passed tests. test_passed = . false . ainteger_I1P = 127_I1P astring = ainteger_I1P test_passed ( 1 ) = astring // '' == '+127' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 1 ) ainteger_I2P = 32767_I2P astring = ainteger_I2P test_passed ( 2 ) = astring // '' == '+32767' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 2 ) ainteger_I4P = 2147483647_I4P astring = ainteger_I4P test_passed ( 3 ) = astring // '' == '+2147483647' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 3 ) ainteger_I8P = - 9223372036854775807_I8P astring = ainteger_I8P test_passed ( 4 ) = astring // '' == '-9223372036854775807' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 4 ) areal_R4P = 3.021e6_R4P astring = areal_R4P test_passed ( 5 ) = astring // '' == '+0.302100E+07' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 5 ) areal_R8P = 7.00907641e23_R8P astring = areal_R8P test_passed ( 6 ) = astring // '' == '+0.700907641000000E+024' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 6 ) areal_R16P = 1.1e200_R16P astring = areal_R16P test_passed ( 7 ) = astring // '' == '+0.110000000000000000000000000000000E+0201' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_assignments","tags":"","loc":"sourcefile/stringifor_test_assignments.f90.html"},{"title":"partition.f90 – FoXy","text":"Contents Programs partition Source Code partition.f90 Source Code !< StringiFor `partition` test. program partition !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `partition` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'lo Wo' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'Hello' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // ' ' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram partition","tags":"","loc":"sourcefile/partition.f90.html"},{"title":"encode.f90 – FoXy","text":"Contents Programs encode Source Code encode.f90 Source Code !< StringiFor `encode` test. program encode !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `encode` test. !< @bug On Travis CI fails. This is very oddy: this works on all my PCs with both Intel and GNU compilers... temporarly disabled. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'How are you?' test_passed ( 1 ) = astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'BASE64: \"' // astring % encode ( codec = 'base64' ) // '\", is correct? ' , test_passed ( 1 ) ! disable for bug on Travis CI test_passed = . true . write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram encode","tags":"","loc":"sourcefile/encode.f90.html"},{"title":"reverse.f90 – FoXy","text":"Contents Programs reverse Source Code reverse.f90 Source Code !< StringiFor `reverse` test. program reverse !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `reverse` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == 'zvutsrqponmlihgfedcba' astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == '9876543210' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram reverse","tags":"","loc":"sourcefile/reverse.f90.html"},{"title":"csv_naive_parser.f90 – FoXy","text":"Contents Programs csv_naive_parser Source Code csv_naive_parser.f90 Source Code !< StringiFor `csv_naive_parser` test. program csv_naive_parser !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `csv_naive_parser` test. !< !< This is an example of th usefulness of StringiFor. !----------------------------------------------------------------------------------------------------------------------------------- use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: lines ( 4 ) !< The CSV file lines. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ! a cars database lines ( 1 ) = 'Year,Make,Model,Description,Price' lines ( 2 ) = '1997,Ford,E350,ac abs moon,3000.00' lines ( 3 ) = '1999,Chevy,Venture \"Extended Edition\", ,4900.00' lines ( 4 ) = '1999,Chevy,Venture \"Extended Edition Very Large\", ,5000.00' ! preparing a CSV file test call write_file ( file = 'file_test_temp.csv' , lines = lines ) ! parsing the just created CSV file call csv % read_file ( file = 'file_test_temp.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! eliminating the file open ( newunit = r , file = 'file_test_temp.csv' ) ; close ( unit = r , status = 'DELETE' ) ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' columns = '----' ! re-use columns for printing separators print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo test_passed ( 1 ) = most_expensive // '' == 'Chevy Venture \"Extended Edition Very Large\"' print \"(A,L1)\" , 'The most expensive car is : ' // most_expensive // ', is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram csv_naive_parser","tags":"","loc":"sourcefile/csv_naive_parser.f90.html"},{"title":"not_equal.f90 – FoXy","text":"Contents Programs not_equal Source Code not_equal.f90 Source Code !< StringiFor `not_equal` test. program not_equal !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `not_equal` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  one ' anotherstring = 'two' acharacter = 'three' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring /= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter /= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '/=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'the same ' anotherstring = 'the same ' acharacter = 'the same ' test_passed ( 4 ) = (( astring /= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring /= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter /= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '/=' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram not_equal","tags":"","loc":"sourcefile/not_equal.f90.html"},{"title":"camelcase.f90 – FoXy","text":"Contents Programs camelcase Source Code camelcase.f90 Source Code !< StringiFor `camelcase` test. program camelcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `camelcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % camelcase () // '' == 'TheQuickBrownFoxJumpsOverTheLazyDog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % camelcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram camelcase","tags":"","loc":"sourcefile/camelcase.f90.html"},{"title":"is_real.f90 – FoXy","text":"Contents Programs is_real Source Code is_real.f90 Source Code !< StringiFor `is_real` test. program is_real !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_real` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_real","tags":"","loc":"sourcefile/is_real.f90.html"},{"title":"sverify.f90 – FoXy","text":"Contents Programs sverify Source Code sverify.f90 Source Code !< StringiFor `sverify` test. program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % verify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % verify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) anothercharacter = acharacter i = astring % verify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"sourcefile/sverify.f90.html"},{"title":"write_lines.f90 – FoXy","text":"Contents Programs write_lines Source Code write_lines.f90 Source Code !< StringiFor `write_lines` test. program write_lines !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `write_lines` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : string , write_lines_standalone => write_lines !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) write ( stdout , \"(A)\" ) \"TBP write_lines\" open ( newunit = scratch , status = 'SCRATCH' ) call anotherstring % write_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"Standalone write_lines\" open ( newunit = scratch , status = 'SCRATCH' ) call write_lines_standalone ( unit = scratch , lines = line , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"TBP write_lines unformatted\" open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) call anotherstring % write_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , form = 'UNFORMATTED' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"Standalone write_lines unformatted\" open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) call write_lines_standalone ( unit = scratch , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , form = 'UNFORMATTED' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram write_lines","tags":"","loc":"sourcefile/write_lines.f90.html"},{"title":"unique.f90 – FoXy","text":"Contents Programs unique Source Code unique.f90 Source Code !< StringiFor `unique` test. program unique !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unique` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+++ab-++cre-++cre-ab+++++' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' write ( stdout , \"(A,L1)\" ) 'Unique:   \"' // astring % unique ( substring = '+' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unique","tags":"","loc":"sourcefile/unique.f90.html"},{"title":"write_file.f90 – FoXy","text":"Contents Programs write_file Source Code write_file.f90 Source Code !< StringiFor `write_file` test. program write_file !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `write_file` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : write_file_standalone => write_file , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) write ( stdout , \"(A)\" ) \"TBP write_file\" call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone write_file\" call write_file_standalone ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo write ( stdout , \"(A)\" ) \"TBP write_file unformatted\" call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone write_file unformatted\" call write_file_standalone ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram write_file","tags":"","loc":"sourcefile/write_file.f90.html"},{"title":"start_end.f90 – FoXy","text":"Contents Programs start_end Source Code start_end.f90 Source Code !< StringiFor `start_end` test. program start_end !< StringiFor `start_end` test. use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 9 ) !< List of passed tests. test_passed = . false . astring = 'Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'start with \"Hello\"? ' , astring % start_with ( prefix = 'Hello' ) test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'start with \"hell\"? ' , astring % start_with ( prefix = 'hell' ) test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (3:) start with \"llo Wor\"? ' , astring % start_with ( prefix = 'llo Wor' , start = 3 ) test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (4:7) start with \"lo W\"? ' , astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ) test_passed ( 5 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"LD!\"? ' , astring % end_with ( suffix = 'LD!' ) test_passed ( 6 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'end with \"lD!\"? ' , astring % end_with ( suffix = 'lD!' ) test_passed ( 7 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (5:) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 5 ) test_passed ( 8 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (8:12) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ) test_passed ( 9 ) = astring % end_with ( suffix = '!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"!\"? ' , astring % end_with ( suffix = '!' ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram start_end","tags":"","loc":"sourcefile/start_end.f90.html"},{"title":"strip.f90 – FoXy","text":"Contents Programs strip Source Code strip.f90 Source Code !< StringiFor `strip` test. program strip !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strip` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Strip:    \"' // astring % strip () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strip","tags":"","loc":"sourcefile/strip.f90.html"},{"title":"insert.f90 – FoXy","text":"Contents Programs insert Source Code insert.f90 Source Code !< StringiFor `insert` test. program insert !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `insert` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 10 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example wow!!!' anotherstring = '... ' acharacter = '... ' write ( stdout , \"(A)\" ) 'Original string:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Substring:  \"' // anotherstring // '\"' write ( stdout , \"(A)\" ) 'Test substring of type string' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=1: \"' // astring % insert ( substring = anotherstring , pos = 1 ) // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=23: \"' // astring % insert ( substring = anotherstring , pos = 23 ) // '\", is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=29: \"' // astring % insert ( substring = anotherstring , pos = 29 ) // '\", is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=-1: \"' // astring % insert ( substring = anotherstring , pos =- 1 ) // '\", is correct? ' , test_passed ( 4 ) test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=100: \"' // astring % insert ( substring = anotherstring , pos = 100 ) // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A)\" ) 'Test substring of type character' test_passed ( 6 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=1: \"' // astring % insert ( substring = acharacter , pos = 1 ) // '\", is correct? ' , test_passed ( 6 ) test_passed ( 7 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=23: \"' // astring % insert ( substring = acharacter , pos = 23 ) // '\", is correct? ' , test_passed ( 7 ) test_passed ( 8 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=29: \"' // astring % insert ( substring = acharacter , pos = 29 ) // '\", is correct? ' , test_passed ( 8 ) test_passed ( 9 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=-1: \"' // astring % insert ( substring = acharacter , pos =- 1 ) // '\", is correct? ' , test_passed ( 9 ) test_passed ( 10 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=100: \"' // astring % insert ( substring = acharacter , pos = 100 ) // '\", is correct? ' , test_passed ( 10 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram insert","tags":"","loc":"sourcefile/insert.f90.html"},{"title":"capitalize.f90 – FoXy","text":"Contents Programs capitalize Source Code capitalize.f90 Source Code !< StringiFor `capitalize` test. program capitalize !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `capitalize` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' test_passed ( 1 ) = astring % capitalize () // '' == 'Say all hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Capitalize: \"' // astring % capitalize () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram capitalize","tags":"","loc":"sourcefile/capitalize.f90.html"},{"title":"unescape.f90 – FoXy","text":"Contents Programs unescape Source Code unescape.f90 Source Code !< StringiFor `unescape` test. program unescape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unescape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\\\s \\\\d+\\\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') write(stdout, \"(A,L1)\") ' Escaped : \"'//astring%unescape(to_unescape='\\')//'\" , is correct ? ', test_passed(1) test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') write(stdout, \"(A,L1)\") ' Escaped : \"'//astring%unescape(to_unescape='s')//'\" , is correct ? ', test_passed(2) write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unescape","tags":"","loc":"sourcefile/unescape.f90.html"},{"title":"decode.f90 – FoXy","text":"Contents Programs decode Source Code decode.f90 Source Code !< StringiFor `decode` test. program decode !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `decode` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : CK , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'SG93IGFyZSB5b3U/' test_passed ( 1 ) = astring % decode ( codec = 'base64' ) // '' == CK_ 'How are you?' write ( stdout , \"(A)\" ) 'BASE64:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Decoded: \"' // astring % decode ( codec = 'base64' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram decode","tags":"","loc":"sourcefile/decode.f90.html"},{"title":"lower_than.f90 – FoXy","text":"Contents Programs lower_than Source Code lower_than.f90 Source Code !< StringiFor `lower_than` test. program lower_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `lower_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring < acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter < astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring < anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring < acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter < astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram lower_than","tags":"","loc":"sourcefile/lower_than.f90.html"},{"title":"stringifor_test_parse_large_csv.f90 – FoXy","text":"Contents Programs stringifor_test_parse_large_csv Source Code stringifor_test_parse_large_csv.f90 Source Code !< StringiFor `csv_naive_parser` test. program stringifor_test_parse_large_csv !< StringiFor `csv_naive_parser` test. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . call csv % read_file ( file = 'src/tests/stringifor_test_parse_large_csv/stringifor_test_parse_large_csv.csv' , is_fast = . true .) call csv % split_chunked ( tokens = rows , sep = new_line ( 'a' ), chunks = 10 ) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' columns = '----' ! re-use columns for printing separators print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' test_passed = . true . print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_parse_large_csv","tags":"","loc":"sourcefile/stringifor_test_parse_large_csv.f90.html"},{"title":"stringifor_string_t.F90 – FoXy","text":"Contents Modules stringifor_string_t Source Code stringifor_string_t.F90 Source Code !< StringiFor, definition of `string` type. module stringifor_string_t !< StringiFor, definition of `string` type. use , intrinsic :: iso_fortran_env , only : iostat_eor use befor64 , only : b64_decode , b64_encode use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P , str implicit none private save public :: CK public :: sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim public :: string integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. procedure , pass ( self ) :: verify => sverify !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: glob => & glob_character , & glob_string !< Glob search, finds all the pathnames matching a given pattern. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: split_chunked !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. procedure , pass ( self ) :: tempname !< Return a safe temporary name suitable for temporary file or directories. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef _R16P_SUPPORTED to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef _R16P_SUPPORTED string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. #endif ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , nopass :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. ! auxiliary methods procedure , private , pass ( self ) :: glob_character !< Glob search (character output). procedure , private , pass ( self ) :: glob_string !< Glob search (string output). procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string ! internal parameters character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len = 1 ), parameter :: SPACE = ' ' !< Space character. character ( kind = CK , len = 1 ), parameter :: TAB = achar ( 9 ) !< Tab character. character ( kind = CK , len = 1 ), parameter :: UIX_DIR_SEP = char ( 47 ) !< Unix/Linux directories separator (/). character ( kind = CK , len = 1 ), parameter :: BACKSLASH = char ( 92 ) !< Backslash character. contains ! public methods ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !< Left adjust a string by removing leading spaces. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) endfunction sadjustl pure function sadjustl_character ( self ) result ( adjusted ) !< Left adjust a string by removing leading spaces (character output). class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( self % raw )) adjusted = adjustl ( self % raw ) endfunction sadjustl_character elemental function sadjustr ( self ) result ( adjusted ) !< Right adjust a string by removing leading spaces. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) endfunction sadjustr pure function sadjustr_character ( self ) result ( adjusted ) !< Right adjust a string by removing leading spaces (character output). class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( self % raw )) adjusted = adjustr ( self % raw ) endfunction sadjustr_character elemental function scount ( self , substring , ignore_isolated ) result ( No ) !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif endfunction scount elemental function sindex_string_string ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_string_string elemental function sindex_string_character ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif endfunction sindex_string_character elemental function sindex_character_string ( string_ , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. character ( kind = CK , len =* ), intent ( in ) :: string_ !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( substring % raw )) then i = index ( string = string_ , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_character_string elemental function slen ( self ) result ( l ) !< Return the length of a string. class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif endfunction slen elemental function slen_trim ( self ) result ( l ) !< Return the length of a string, ignoring any trailing blanks. class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif endfunction slen_trim elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) endfunction srepeat_string_string elemental function srepeat_character_string ( rstring , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. repeated % raw = repeat ( string = rstring , ncopies = ncopies ) endfunction srepeat_character_string elemental function sscan_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sscan_string_string elemental function sscan_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sscan_string_character elemental function sscan_character_string ( sstring , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. character ( kind = CK , len =* ), intent ( in ) :: sstring !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = scan ( string = sstring , set = set % raw , back = back ) else i = 0 endif endfunction sscan_character_string elemental function strim ( self ) result ( trimmed ) !< Remove leading spaces. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) endfunction strim elemental function sverify ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sverify ! auxiliary methods elemental function basedir ( self , sep ) !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif endfunction basedir elemental function basename ( self , sep , extension , strip_last_extension ) !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif endfunction basename elemental function camelcase ( self , sep ) !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !< Return a string with its first character capitalized and the rest lowercased. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif endfunction capitalize pure function chars ( self ) result ( raw ) !< Return the raw characters data. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif endfunction chars elemental function decode ( self , codec ) result ( decoded ) !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif endfunction decode elemental function encode ( self , codec ) result ( encoded ) !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !< Escape backslashes (or custom escape character). class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif endfunction escape elemental function extension ( self ) !< Return the extension of a string containing a file name. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif endfunction extension elemental function fill ( self , width , right , filling_char ) result ( filled ) !< Pad string on the left (or right) with zeros (or other char) to fill width. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif endfunction fill elemental subroutine free ( self ) !< Free dynamic memory. class ( string ), intent ( inout ) :: self !< The string. if ( allocated ( self % raw )) deallocate ( self % raw ) endsubroutine free subroutine glob_character ( self , pattern , list ) !< Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. character ( len = :), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ), allocatable :: list_ (:) !< List of matching pathnames. integer ( I4P ) :: max_len !< Maximum length. integer ( I4P ) :: matches_number !< Matches number. integer ( I4P ) :: m !< Counter. call self % glob ( pattern = pattern , list = list_ ) if ( allocated ( list_ )) then matches_number = size ( list_ , dim = 1 ) max_len = 0 do m = 1 , matches_number max_len = max ( max_len , list_ ( m )% len ()) enddo allocate ( character ( max_len ) :: list ( 1 : matches_number )) do m = 1 , matches_number list ( m ) = list_ ( m )% chars () enddo endif endsubroutine glob_character subroutine glob_string ( self , pattern , list ) !< Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. type ( string ), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ) :: tempfile !< Safe temporary file. character ( len = :), allocatable :: tempname !< Safe temporary name. integer ( I4P ) :: tempunit !< Unit of temporary file. tempname = self % tempname () call execute_command_line ( 'ls -1 ' // trim ( adjustl ( pattern )) // ' > ' // tempname ) call tempfile % read_file ( file = tempname ) call tempfile % split ( sep = new_line ( 'a' ), tokens = list ) open ( newunit = tempunit , file = tempname ) close ( unit = tempunit , status = 'delete' ) endsubroutine glob_string elemental function insert_character ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif endfunction insert_character elemental function insert_string ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif endfunction insert_string pure function join_strings ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_strings pure function join_characters ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_characters elemental function lower ( self ) !< Return a string with all lowercase characters. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif endfunction lower pure function partition ( self , sep ) result ( partitions ) !< Split string at separator and return the 3 parts (before, the separator and after). class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif endfunction partition subroutine read_file ( self , file , is_fast , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note *Fast* file reading allows a very efficient reading of streamed file, but it dumps file as single streamed string. class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. logical , intent ( in ), optional :: is_fast !< Flag to enable (super) fast file reading. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. logical :: is_fast_ !< Flag to enable (super) fast file reading, local variable. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. integer ( I4P ) :: filesize !< Size of the file for fast reading. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then is_fast_ = . false . ; if ( present ( is_fast )) is_fast_ = is_fast if ( is_fast_ ) then open ( newunit = unit , file = file , access = 'STREAM' , form = 'UNFORMATTED' , iomsg = iomsg_ , iostat = iostat_ ) inquire ( file = file , size = filesize ) if ( allocated ( self % raw )) deallocate ( self % raw ) allocate ( character ( len = filesize ) :: self % raw ) read ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw close ( unit ) else form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif else iostat_ = 1 iomsg_ = 'file not found' endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file subroutine read_line ( self , unit , form , iostat , iomsg ) !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_line subroutine read_lines ( self , unit , form , iostat , iomsg ) !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return endsubroutine read_lines elemental function replace ( self , old , new , count ) result ( replaced ) !< Return a string with all occurrences of substring old replaced by new. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif endfunction replace elemental function reverse ( self ) result ( reversed ) !< Return a reversed string. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif endfunction reverse function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ endfunction search pure function slice ( self , istart , iend ) result ( raw ) !< Return the raw characters data sliced. !< !<### Example !< !<```fortran !< type(string) :: astring        !< A string. !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) ! print \"Brown fox Jumps\" !<``` class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif endfunction slice elemental function snakecase ( self , sep ) !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif endfunction snakecase pure subroutine split ( self , tokens , sep , max_tokens ) !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note If `max_tokens` is passed the returned number of tokens is either `max_tokens` or `max_tokens + 1`. class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. integer , intent ( in ), optional :: max_tokens !< Fix the maximum number of returned tokens. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) if ( No > 0 ) then if ( present ( max_tokens )) then if ( max_tokens < No . and . max_tokens > 0 ) No = max_tokens endif allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No - 1 tokens ( t ) = temp_toks ( 1 , t + 1 ) enddo tokens ( No ) = temp_toks ( 3 , No ) else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif else allocate ( tokens ( 1 )) tokens ( 1 ) = self endif endif endsubroutine split pure subroutine split_chunked ( self , tokens , chunks , sep ) !< Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note The split is performed in chunks of `#chunks` to avoid excessive memory consumption. class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. integer , intent ( in ) :: chunks !< Number of chunks. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: Nt !< Number of actual tokens. integer :: t !< Counter. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep Nt = self % count ( sep_ ) if ( self % start_with ( prefix = sep_ )) Nt = Nt - 1 if ( self % end_with ( suffix = sep_ )) Nt = Nt - 1 t = 0 call self % split ( tokens = tokens , sep = sep_ , max_tokens = chunks ) do t = size ( tokens , dim = 1 ) if ( t > Nt ) exit call split_last_token ( tokens = tokens , max_tokens = chunks ) enddo t = size ( tokens , dim = 1 ) if ( tokens ( t )% count ( sep_ ) > 0 ) then call split_last_token ( tokens = tokens ) endif endif contains pure subroutine split_last_token ( tokens , max_tokens ) !< Split last token. type ( string ), allocatable , intent ( inout ) :: tokens (:) !< Tokens substring. integer , intent ( in ), optional :: max_tokens !< Max tokens returned. type ( string ), allocatable :: tokens_ (:) !< Temporary tokens. type ( string ), allocatable :: tokens_swap (:) !< Swap tokens. integer :: Nt_ !< Number of last created tokens. call tokens ( t )% split ( tokens = tokens_ , sep = sep_ , max_tokens = max_tokens ) if ( allocated ( tokens_ )) then Nt_ = size ( tokens_ , dim = 1 ) if ( Nt_ >= 1 ) then allocate ( tokens_swap ( 1 : t - 1 + Nt_ )) tokens_swap ( 1 : t - 1 ) = tokens ( 1 : t - 1 ) tokens_swap ( t :) = tokens_ (:) call move_alloc ( from = tokens_swap , to = tokens ) endif deallocate ( tokens_ ) endif endsubroutine split_last_token endsubroutine split_chunked elemental function startcase ( self , sep ) !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif endfunction startcase elemental function strip ( self , remove_nulls ) !< Return a copy of the string with the leading and trailing characters removed. class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif endfunction strip elemental function swapcase ( self ) !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif endfunction swapcase function tempname ( self , is_file , prefix , path ) !< Return a safe temporary name suitable for temporary file or directories. class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: is_file !< True if tempname should be used for file (the default). character ( * ), intent ( in ), optional :: prefix !< Name prefix, otherwise self is used (if allocated). character ( * ), intent ( in ), optional :: path !< Path where file/directory should be used, default `./`. character ( len = :), allocatable :: tempname !< Safe (unique) temporary name. logical :: is_file_ !< True if tempname should be used for file (the default). character ( len = :), allocatable :: prefix_ !< Name prefix, otherwise self is used (if allocated). character ( len = :), allocatable :: path_ !< Path where file/directory should be used, default `./`. logical , save :: is_initialized = . false . !< Status of random seed initialization. real ( R4P ) :: random_real !< Random number (real). integer ( I4P ) :: random_integer !< Random number (integer). logical :: is_hold !< Flag to check if a safe tempname has been found. is_file_ = . true . ; if ( present ( is_file )) is_file_ = is_file path_ = '' ; if ( present ( path )) path_ = path prefix_ = '' if ( present ( prefix )) then prefix_ = prefix elseif ( allocated ( self % raw )) then prefix_ = self % raw endif if (. not . is_initialized ) then call random_seed is_initialized = . true . endif tempname = repeat ( ' ' , len ( path_ ) + len ( prefix_ ) + 10 ) ! [path_] + [prefix_] + 6 random chars + [.tmp] do call random_number ( random_real ) random_integer = transfer ( random_real , random_integer ) random_integer = iand ( random_integer , 16777215_I4P ) if ( is_file_ ) then write ( tempname , '(A,Z6.6,A)' ) path_ // prefix_ , random_integer , '.tmp' else write ( tempname , '(A,Z6.6)' ) path_ // prefix_ , random_integer tempname = trim ( tempname ) endif inquire ( file = tempname , exist = is_hold ) if (. not . is_hold ) exit enddo endfunction tempname elemental function to_integer_I1P ( self , kind ) result ( to_number ) !< Cast string to integer (I1P). class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I1P elemental function to_integer_I2P ( self , kind ) result ( to_number ) !< Cast string to integer (I2P). class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I2P elemental function to_integer_I4P ( self , kind ) result ( to_number ) !< Cast string to integer (I4P). class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I4P elemental function to_integer_I8P ( self , kind ) result ( to_number ) !< Cast string to integer (I8P). class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I8P elemental function to_real_R4P ( self , kind ) result ( to_number ) !< Cast string to real (R4P). class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R4P elemental function to_real_R8P ( self , kind ) result ( to_number ) !< Cast string to real (R8P). class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R8P elemental function to_real_R16P ( self , kind ) result ( to_number ) !< Cast string to real (R16P). class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R16P elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !< Unescape double backslashes (or custom escaped character). class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif endfunction unescape elemental function unique ( self , substring ) result ( uniq ) !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif endfunction unique elemental function upper ( self ) !< Return a string with all uppercase characters. class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif endfunction upper subroutine write_file ( self , file , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file subroutine write_line ( self , unit , form , iostat , iomsg ) !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_line subroutine write_lines ( self , unit , form , iostat , iomsg ) !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif endsubroutine write_lines ! inquire elemental function end_with ( self , suffix , start , end , ignore_null_eof ) !< Return true if a string ends with a specified suffix. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical , intent ( in ), optional :: ignore_null_eof !< Ignore null character at the end of file. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. logical :: ignore_null_eof_ !< Ignore null character at the end of file, local variable. end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end ignore_null_eof_ = . false . ; if ( present ( ignore_null_eof )) ignore_null_eof_ = ignore_null_eof if ( ignore_null_eof_ . and .( self % raw ( end_ : end_ ) == char ( 0 ))) end_ = end_ - 1 if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = self % raw ( end_ - len ( suffix ) + 1 : end_ ) == suffix endif endif endfunction end_with elemental function is_allocated ( self ) !< Return true if the string is allocated. class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. is_allocated = allocated ( self % raw ) endfunction is_allocated elemental function is_digit ( self ) !< Return true if all characters in the string are digits. class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif endfunction is_digit elemental function is_integer ( self , allow_spaces ) !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif endfunction is_integer elemental function is_lower ( self ) !< Return true if all characters in the string are lowercase. class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif endfunction is_lower elemental function is_number ( self , allow_spaces ) !< Return true if the string contains a number (real or integer). class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) endfunction is_number elemental function is_real ( self , allow_spaces ) !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif endfunction is_real elemental function is_upper ( self ) !< Return true if all characters in the string are uppercase. class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif endfunction is_upper elemental function start_with ( self , prefix , start , end ) !< Return true if a string starts with a specified prefix. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif endfunction start_with ! private methods ! assignments elemental subroutine string_assign_string ( lhs , rhs ) !< Assignment operator from string input. class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % raw )) lhs % raw = rhs % raw endsubroutine string_assign_string elemental subroutine string_assign_character ( lhs , rhs ) !< Assignment operator from character input. class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. lhs % raw = rhs endsubroutine string_assign_character elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !< Assignment operator from real input. class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I1P elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !< Assignment operator from real input. class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I2P elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !< Assignment operator from real input. class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I4P elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !< Assignment operator from real input. class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I8P elemental subroutine string_assign_real_R4P ( lhs , rhs ) !< Assignment operator from real input. class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R4P elemental subroutine string_assign_real_R8P ( lhs , rhs ) !< Assignment operator from real input. class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R8P elemental subroutine string_assign_real_R16P ( lhs , rhs ) !< Assignment operator from real input. class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R16P ! contatenation operators pure function string_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !< Concatenation with character. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !< Concatenation with character. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif endfunction character_concat_string_string ! logical operators elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs % raw endfunction string_eq_string elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs endfunction string_eq_character elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to character (inverted) logical operator. character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw == lhs endfunction character_eq_string elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to string logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs % raw endfunction string_ne_string elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !< Not equal to character logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs endfunction string_ne_character elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to character (inverted) logical operator. character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw /= lhs endfunction character_ne_string elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to string logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs % raw endfunction string_lt_string elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !< Lower than to character logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs endfunction string_lt_character elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to character (inverted) logical operator. character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs < rhs % raw endfunction character_lt_string elemental function string_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to string logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs % raw endfunction string_le_string elemental function string_le_character ( lhs , rhs ) result ( is_it ) !< Lower equal than to character logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs endfunction string_le_character elemental function character_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to character (inverted) logical operator. character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs <= rhs % raw endfunction character_le_string elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to string logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs % raw endfunction string_ge_string elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !< Greater equal than to character logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs endfunction string_ge_character elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to character (inverted) logical operator. character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs >= rhs % raw endfunction character_ge_string elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to string logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs % raw endfunction string_gt_string elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !< Greater than to character logical operator. class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs endfunction string_gt_character elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to character (inverted) logical operator. character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs > rhs % raw endfunction character_gt_string ! IO subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif endsubroutine read_formatted subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the end of record condition to the ! caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo endsubroutine read_delimited subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) endsubroutine read_undelimited_listdirected subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo endsubroutine read_undelimited subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_formatted subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endsubroutine read_unformatted subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_unformatted ! miscellanea elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !< Return a string with the first occurrence of substring old replaced by new. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif endfunction replace_one_occurrence ! non type-bound-procedures subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif endsubroutine get_delimiter_mode subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character in the current record. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo endsubroutine get_next_non_blank_character_this_record subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character, advancing records if necessary. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo endsubroutine get_next_non_blank_character_any_record subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' endsubroutine get_decimal_mode endmodule stringifor_string_t","tags":"","loc":"sourcefile/stringifor_string_t.f90.html"},{"title":"stringifor.F90 – FoXy","text":"Contents Modules stringifor Source Code stringifor.F90 Source Code !< StringiFor, Strings Fortran, yet another stringify Fortran module module stringifor !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, Strings Fortran, yet another stringify Fortran module !----------------------------------------------------------------------------------------------------------------------------------- use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P use stringifor_string_t , only : CK , & sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim , & string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! expose StingiFor objects public :: CK public :: string ! expose StingiFor overloaded builtins public :: adjustl , adjustr , count , index , len , len_trim , repeat , scan , trim ! expose StingiFor new procedures public :: read_file , read_lines , write_file , write_lines ! expose PENF kinds public :: I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! builtins overloading interfaces interface adjustl !< Builtin adjustl overloading. module procedure sadjustl_character endinterface adjustl interface adjustr !< Builtin adjustr overloading. module procedure sadjustr_character endinterface adjustr interface count !< Builtin count overloading. module procedure count_substring endinterface interface index !< Builtin index overloading. module procedure sindex_string_string , sindex_string_character , sindex_character_string endinterface index interface len !< Builtin len overloading. module procedure slen endinterface len interface len_trim !< Builtin len_trim overloading. module procedure slen_trim endinterface len_trim interface repeat !< Builtin repeat overloading. module procedure srepeat_string_string endinterface repeat interface scan !< Builtin scan overloading. module procedure sscan_string_string , sscan_string_character , sscan_character_string endinterface scan interface trim !< Builtin trim overloading. module procedure strim endinterface trim !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function count_substring ( string_ , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string_ !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string_ )) return c1 = 1 do c2 = index ( string = string_ ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring subroutine read_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file subroutine read_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines subroutine write_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected-formatted unit. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines subroutine write_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html"},{"title":"befor64-doctest-29.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-29.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character (:), allocatable :: code64 code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) print \"(L1)\" , code64 == 'hello' endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-29.f90.html"},{"title":"befor64-doctest-16.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-16.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-16.f90.html"},{"title":"befor64-doctest-28.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-28.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I1P ) :: scalar_I1 call b64_decode ( code = 'eA==' , n = scalar_I1 ) print \"(L1)\" , scalar_I1 == 120_I1P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-28.f90.html"},{"title":"befor64-doctest-14.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-14.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-14.f90.html"},{"title":"befor64-doctest-5.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-5.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I8P ) :: array_I8 ( 1 : 4 ) call b64_decode_up ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , up = array_I8 ) print \"(L1)\" , str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-5.f90.html"},{"title":"befor64-doctest-27.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-27.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I2P ) :: scalar_I2 call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) print \"(L1)\" , scalar_I2 ==- 203_I2P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-27.f90.html"},{"title":"befor64-doctest-17.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-17.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-17.f90.html"},{"title":"befor64-doctest-15.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-15.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-15.f90.html"},{"title":"befor64-doctest-23.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-23.f90 Source Code program volatile_doctest use befor64 use befor64 use penf real ( R8P ) :: scalar_R8 call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) print \"(L1)\" , scalar_R8 == 1._R8P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-23.f90.html"},{"title":"befor64-doctest-9.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-9.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = 23_I8P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-9.f90.html"},{"title":"befor64-doctest-22.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-22.f90 Source Code program volatile_doctest use befor64 use befor64 use penf real ( R16P ) :: scalar_R16 call b64_decode ( code = 'CKwcWmTHYEA=' , n = scalar_R16 ) print \"(L1)\" , scalar_R16 == 13 4.231_R16P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-22.f90.html"},{"title":"befor64-doctest-30.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-30.f90 Source Code program volatile_doctest use befor64 use befor64 use penf real ( R16P ) :: array_R16 ( 1 : 2 ) call b64_decode ( code = 'AAAAAABAXkCPwvUoXI8CQA==' , n = array_R16 ) print \"(L1)\" , str ( n = array_R16 ) == str ( n = [ 12 1._R16P , 2.32_R16P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-30.f90.html"},{"title":"befor64-doctest-36.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-36.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I1P ) :: array_I1 ( 1 : 2 ) call b64_decode ( code = 'eP8=' , n = array_I1 ) print \"(L1)\" , str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-36.f90.html"},{"title":"befor64-doctest-26.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-26.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I4P ) :: scalar_I4 call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) print \"(L1)\" , scalar_I4 == 2023_I4P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-26.f90.html"},{"title":"befor64-doctest-25.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-25.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I8P ) :: scalar_I8 call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) print \"(L1)\" , scalar_I8 == 23_I8P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-25.f90.html"},{"title":"befor64-doctest-12.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-12.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = 120_I1P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-12.f90.html"},{"title":"befor64-doctest-24.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-24.f90 Source Code program volatile_doctest use befor64 use befor64 use penf real ( R4P ) :: scalar_R4 call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) print \"(L1)\" , scalar_R4 == 0._R4P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-24.f90.html"},{"title":"befor64-doctest-10.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-10.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = 2023_I4P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-10.f90.html"},{"title":"befor64-doctest-7.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-7.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = 1._R8P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-7.f90.html"},{"title":"befor64-doctest-4.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-4.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I4P ) :: scalar_I4 call b64_decode_up ( code = '5wcAAA==' , up = scalar_I4 ) print \"(L1)\" , scalar_I4 == 2023_I4P endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-4.f90.html"},{"title":"befor64-doctest-32.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-32.f90 Source Code program volatile_doctest use befor64 use befor64 use penf real ( R4P ) :: array_R4 ( 1 : 2 ) call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) print \"(L1)\" , str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-32.f90.html"},{"title":"befor64-doctest-35.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-35.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I2P ) :: array_I2 ( 1 : 2 ) call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) print \"(L1)\" , str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-35.f90.html"},{"title":"befor64-doctest-8.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-8.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = 0._R4P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-8.f90.html"},{"title":"befor64-doctest-34.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-34.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I4P ) :: array_I4 ( 1 : 2 ) call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) print \"(L1)\" , str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-34.f90.html"},{"title":"befor64-doctest-20.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-20.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-20.f90.html"},{"title":"befor64-doctest-3.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-3.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode_up ( up = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-3.f90.html"},{"title":"befor64-doctest-19.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-19.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-19.f90.html"},{"title":"befor64-doctest-11.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-11.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n =- 203_I2P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-11.f90.html"},{"title":"befor64-doctest-33.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-33.f90 Source Code program volatile_doctest use befor64 use befor64 use penf integer ( I8P ) :: array_I8 ( 1 : 4 ) call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) print \"(L1)\" , str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-33.f90.html"},{"title":"befor64-doctest-13.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-13.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( s = 'hello' , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-13.f90.html"},{"title":"befor64-doctest-2.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-2.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode_up ( up = 1._R8P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-2.f90.html"},{"title":"befor64-doctest-6.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-6.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = 13 4.231_R16P , code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-6.f90.html"},{"title":"befor64-doctest-31.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-31.f90 Source Code program volatile_doctest use befor64 use befor64 use penf real ( R8P ) :: array_R8 ( 1 : 2 ) call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) print \"(L1)\" , str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-31.f90.html"},{"title":"befor64-doctest-21.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-21.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-21.f90.html"},{"title":"befor64-doctest-37.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-37.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( 5 ) :: array_s ( 1 : 2 ) call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) print \"(L1)\" , array_s ( 1 ) // array_s ( 2 ) == 'helloworld' endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-37.f90.html"},{"title":"befor64-doctest-1.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-1.f90 Source Code program volatile_doctest use befor64 use befor64 call b64_init print \"(L1)\" , is_b64_initialized endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-1.f90.html"},{"title":"befor64-doctest-18.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64-doctest-18.f90 Source Code program volatile_doctest use befor64 use befor64 use penf character ( len = :), allocatable :: code64 call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) print \"(A)\" , code64 endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64-doctest-18.f90.html"},{"title":"befor64_pack_data_m-doctest-25.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-25.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I2P ) :: a1 ( 1 ) integer ( I1P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 3 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-25.f90.html"},{"title":"befor64_pack_data_m-doctest-12.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-12.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I8P ) :: a1 ( 1 ) real ( R4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-12.f90.html"},{"title":"befor64_pack_data_m-doctest-22.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-22.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I2P ) :: a1 ( 1 ) real ( R4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-22.f90.html"},{"title":"befor64_pack_data_m-doctest-2.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-2.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R8P ) :: a1 ( 1 ) integer ( I8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 9 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-2.f90.html"},{"title":"befor64_pack_data_m-doctest-15.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-15.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I8P ) :: a1 ( 1 ) integer ( I1P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 9 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-15.f90.html"},{"title":"befor64_pack_data_m-doctest-23.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-23.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I2P ) :: a1 ( 1 ) integer ( I8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 3 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-23.f90.html"},{"title":"befor64_pack_data_m-doctest-24.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-24.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I2P ) :: a1 ( 1 ) integer ( I4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 3 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-24.f90.html"},{"title":"befor64_pack_data_m-doctest-4.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-4.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R8P ) :: a1 ( 1 ) integer ( I2P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 9 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-4.f90.html"},{"title":"befor64_pack_data_m-doctest-18.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-18.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I4P ) :: a1 ( 1 ) integer ( I8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-18.f90.html"},{"title":"befor64_pack_data_m-doctest-21.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-21.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I2P ) :: a1 ( 1 ) real ( R8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-21.f90.html"},{"title":"befor64_pack_data_m-doctest-19.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-19.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I4P ) :: a1 ( 1 ) integer ( I2P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-19.f90.html"},{"title":"befor64_pack_data_m-doctest-26.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-26.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I1P ) :: a1 ( 1 ) real ( R8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-26.f90.html"},{"title":"befor64_pack_data_m-doctest-17.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-17.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I4P ) :: a1 ( 1 ) real ( R4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-17.f90.html"},{"title":"befor64_pack_data_m-doctest-27.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-27.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I1P ) :: a1 ( 1 ) real ( R4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-27.f90.html"},{"title":"befor64_pack_data_m-doctest-5.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-5.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R8P ) :: a1 ( 1 ) integer ( I1P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 9 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-5.f90.html"},{"title":"befor64_pack_data_m-doctest-9.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-9.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R4P ) :: a1 ( 1 ) integer ( I2P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-9.f90.html"},{"title":"befor64_pack_data_m-doctest-6.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-6.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R4P ) :: a1 ( 1 ) real ( R8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-6.f90.html"},{"title":"befor64_pack_data_m-doctest-8.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-8.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R4P ) :: a1 ( 1 ) integer ( I4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-8.f90.html"},{"title":"befor64_pack_data_m-doctest-10.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-10.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R4P ) :: a1 ( 1 ) integer ( I1P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-10.f90.html"},{"title":"befor64_pack_data_m-doctest-11.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-11.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I8P ) :: a1 ( 1 ) real ( R8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-11.f90.html"},{"title":"befor64_pack_data_m-doctest-7.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-7.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R4P ) :: a1 ( 1 ) integer ( I8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-7.f90.html"},{"title":"befor64_pack_data_m-doctest-1.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-1.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R8P ) :: a1 ( 1 ) real ( R4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-1.f90.html"},{"title":"befor64_pack_data_m-doctest-29.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-29.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I1P ) :: a1 ( 1 ) integer ( I4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 2 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-29.f90.html"},{"title":"befor64_pack_data_m-doctest-13.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-13.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I8P ) :: a1 ( 1 ) integer ( I4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 9 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-13.f90.html"},{"title":"befor64_pack_data_m-doctest-30.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-30.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I1P ) :: a1 ( 1 ) integer ( I2P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 2 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-30.f90.html"},{"title":"befor64_pack_data_m-doctest-14.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-14.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I8P ) :: a1 ( 1 ) integer ( I2P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 9 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-14.f90.html"},{"title":"befor64_pack_data_m-doctest-3.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-3.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf real ( R8P ) :: a1 ( 1 ) integer ( I4P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 9 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-3.f90.html"},{"title":"befor64_pack_data_m-doctest-16.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-16.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I4P ) :: a1 ( 1 ) real ( R8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( size ( pack , dim = 1 )) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-16.f90.html"},{"title":"befor64_pack_data_m-doctest-28.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-28.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I1P ) :: a1 ( 1 ) integer ( I8P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 2 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-28.f90.html"},{"title":"befor64_pack_data_m-doctest-20.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code befor64_pack_data_m-doctest-20.f90 Source Code program volatile_doctest use befor64_pack_data_m use befor64 use penf integer ( I4P ) :: a1 ( 1 ) integer ( I1P ) :: a2 ( 1 ) integer ( I1P ), allocatable :: pack (:) a1 ( 1 ) = 0 a2 ( 1 ) = 1 call pack_data ( a1 = a1 , a2 = a2 , packed = pack ) print * , pack ( 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/befor64_pack_data_m-doctest-20.f90.html"},{"title":"befor64_pack_data_m.F90 – FoXy","text":"Contents Modules befor64_pack_data_m Source Code befor64_pack_data_m.F90 Source Code !< KISS library for packing heterogeneous data into single (homogeneous) packed one. ! module befor64_pack_data_m !< KISS library for packing heterogeneous data into single (homogeneous) packed one. use penf implicit none private public :: pack_data interface pack_data !< Pack different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```ortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```ortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R8P)                 :: a1(1) !< real(R4P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R8P)                 :: a1(1) !< integer(I8P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(9) !<``` !=> 1 <<< real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R8P)                 :: a1(1) !< integer(I4P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(9) !<``` !=> 1 <<< real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R8P)                 :: a1(1) !< integer(I2P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(9) !<``` !=> 1 <<< real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R8P)                 :: a1(1) !< integer(I1P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(9) !<``` !=> 1 <<< real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R4P)                 :: a1(1) !< real(R8P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R4P)                 :: a1(1) !< integer(I8P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(5) !<``` !=> 1 <<< real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R4P)                 :: a1(1) !< integer(I4P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(5) !<``` !=> 1 <<< real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R4P)                 :: a1(1) !< integer(I2P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(5) !<``` !=> 1 <<< real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< real(R4P)                 :: a1(1) !< integer(I1P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(5) !<``` !=> 1 <<< real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I8P)              :: a1(1) !< real(R8P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I8P)              :: a1(1) !< real(R4P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I8P)              :: a1(1) !< integer(I4P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(9) !<``` !=> 1 <<< integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I8P)              :: a1(1) !< integer(I2P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(9) !<``` !=> 1 <<< integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I8P)              :: a1(1) !< integer(I1P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(9) !<``` !=> 1 <<< integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I4P)              :: a1(1) !< real(R8P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I4P)              :: a1(1) !< real(R4P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I4P)              :: a1(1) !< integer(I8P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(5) !<``` !=> 1 <<< integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I4P)              :: a1(1) !< integer(I2P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(5) !<``` !=> 1 <<< integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I4P)              :: a1(1) !< integer(I1P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(5) !<``` !=> 1 <<< integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I2P)              :: a1(1) !< real(R8P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I2P)              :: a1(1) !< real(R4P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I2P)              :: a1(1) !< integer(I8P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(3) !<``` !=> 1 <<< integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I2P)              :: a1(1) !< integer(I4P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(3) !<``` !=> 1 <<< integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I2P)              :: a1(1) !< integer(I1P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(3) !<``` !=> 1 <<< integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I1P)              :: a1(1) !< real(R8P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I1P)              :: a1(1) !< real(R4P)                 :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(size(pack, dim=1)) !<``` !=> 63 <<< integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I1P)              :: a1(1) !< integer(I8P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(2) !<``` !=> 1 <<< integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I1P)              :: a1(1) !< integer(I4P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(2) !<``` !=> 1 <<< integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I4 pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. !< !<```fortran !< use befor64 !< use penf !< integer(I1P)              :: a1(1) !< integer(I2P)              :: a2(1) !< integer(I1P), allocatable :: pack(:) !< a1(1) = 0 !< a2(1) = 1 !< call pack_data(a1=a1, a2=a2, packed=pack) !< print *, pack(2) !<``` !=> 1 <<< integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , p1 ) p2 = transfer ( a2 , p2 ) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I2 endmodule befor64_pack_data_m","tags":"","loc":"sourcefile/befor64_pack_data_m.f90.html"},{"title":"befor64.F90 – FoXy","text":"Contents Modules befor64 Source Code befor64.F90 Source Code !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. module befor64 !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. use penf use befor64_pack_data_m implicit none private public :: is_b64_initialized , b64_init public :: b64_encode , b64_encode_up public :: b64_decode , b64_decode_up public :: pack_data logical :: is_b64_initialized = . false . !< Flag for checking the initialization of the library. character ( 64 ) :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" !< Base64 alphabet. interface b64_encode !< Encode numbers (integer and real) to base64. !< !< This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both !< scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```ortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```ortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef _R16P_SUPPORTED b64_encode_R16 , b64_encode_R16_a , & #endif b64_encode_R8 , b64_encode_R8_a , & b64_encode_R4 , b64_encode_R4_a , & b64_encode_I8 , b64_encode_I8_a , & b64_encode_I4 , b64_encode_I4_a , & b64_encode_I2 , b64_encode_I2_a , & b64_encode_I1 , b64_encode_I1_a , & b64_encode_string , b64_encode_string_a endinterface interface b64_encode_up !< Encode unlimited polymorphic variable to base64. !< !< This is an interface for encoding both scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```ortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```ortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_encode_up , b64_encode_up_a endinterface interface b64_decode !< Decode numbers (integer and real) from base64. !< !< This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both !< scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```ortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode(code='AAAAAAAA8D8=',n=decoded) !<``` !< !<#### Array decoding !<```ortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef _R16P_SUPPORTED b64_decode_R16 , b64_decode_R16_a , & #endif b64_decode_R8 , b64_decode_R8_a , & b64_decode_R4 , b64_decode_R4_a , & b64_decode_I8 , b64_decode_I8_a , & b64_decode_I4 , b64_decode_I4_a , & b64_decode_I2 , b64_decode_I2_a , & b64_decode_I1 , b64_decode_I1_a , & b64_decode_string , b64_decode_string_a endinterface interface b64_decode_up !< Decode unlimited polymorphic variable from base64. !< !< This is an interface for decoding both scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```ortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode_up(code='AAAAAAAA8D8=',up=decoded) !<``` !< !<#### Array decoding !<```ortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',up=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_decode_up , b64_decode_up_a endinterface contains subroutine b64_init () !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !< !<```fortran !< use befor64 !< call b64_init !< print \"(L1)\", is_b64_initialized !<``` !=> T <<< if (. not . is_initialized ) call penf_init is_b64_initialized = . true . endsubroutine b64_init pure subroutine encode_bits ( bits , padd , code ) !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) endsubroutine encode_bits pure subroutine decode_bits ( code , bits ) !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo endsubroutine decode_bits subroutine b64_encode_up ( up , code ) !< Encode an unlimited polymorphic scalar to base64. !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode_up(up=1._R8P, code=code64) !< print \"(A)\", code64 !<``` !=> AAAAAAAA8D8= <<< class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect endsubroutine b64_encode_up pure subroutine b64_encode_up_a ( up , code ) !< Encode an unlimited polymorphic array to base64. !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode_up(up=[0._R4P,-32.12_R4P], code=code64) !< print \"(A)\", code64 !<``` !=> AAAAAOF6AMI= <<< class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect endsubroutine b64_encode_up_a subroutine b64_decode_up ( code , up ) !< Decode an unlimited polymorphic scalar from base64. !< !<```fortran !< use befor64 !< use penf !< integer(I4P) :: scalar_I4 !< call b64_decode_up(code='5wcAAA==',up=scalar_I4) !< print \"(L1)\", scalar_I4==2023_I4P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect endsubroutine b64_decode_up subroutine b64_decode_up_a ( code , up ) !< Decode an unlimited polymorphic array from base64. !< !<```fortran !< use befor64 !< use penf !< integer(I8P) :: array_I8(1:4) !< call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=', up=array_I8) !< print \"(L1)\", str(n=array_I8)==str(n=[23_I8P,324_I8P,25456656_I8P,2_I8P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect endsubroutine b64_decode_up_a pure subroutine b64_encode_R16 ( n , code ) !< Encode scalar number to base64 (R16P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=134.231_R16P, code=code64) !< print \"(A)\", code64 !<``` !=> CKwcWmTHYEA= <<< real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R16 pure subroutine b64_encode_R8 ( n , code ) !< Encode scalar number to base64 (R8P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=1._R8P, code=code64) !< print \"(A)\", code64 !<``` !=> AAAAAAAA8D8= <<< real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R8 pure subroutine b64_encode_R4 ( n , code ) !< Encode scalar number to base64 (R4P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=0._R4P, code=code64) !< print \"(A)\", code64 !<``` !=> AAAAAA== <<< real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R4 pure subroutine b64_encode_I8 ( n , code ) !< Encode scalar number to base64 (I8P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=23_I8P, code=code64) !< print \"(A)\", code64 !<``` !=> FwAAAAAAAAA= <<< integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I8 pure subroutine b64_encode_I4 ( n , code ) !< Encode scalar number to base64 (I4P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=2023_I4P, code=code64) !< print \"(A)\", code64 !<``` !=> 5wcAAA== <<< integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I4 pure subroutine b64_encode_I2 ( n , code ) !< Encode scalar number to base64 (I2P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=-203_I2P, code=code64) !< print \"(A)\", code64 !<``` !=> Nf8= <<< integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I2 pure subroutine b64_encode_I1 ( n , code ) !< Encode scalar number to base64 (I1P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=120_I1P, code=code64) !< print \"(A)\", code64 !<``` !=> eA== <<< integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I1 pure subroutine b64_encode_string ( s , code ) !< Encode scalar string to base64. !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(s='hello', code=code64) !< print \"(A)\", code64 !<``` !=> aGVsbG8= <<< character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_string pure subroutine b64_encode_R16_a ( n , code ) !< Encode array numbers to base64 (R16P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=[121._R16P,2.32_R16P], code=code64) !< print \"(A)\", code64 !<``` !=> AAAAAABAXkCPwvUoXI8CQA== <<< real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R16_a pure subroutine b64_encode_R8_a ( n , code ) !< Encode array numbers to base64 (R8P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=[1._R8P,2._R8P], code=code64) !< print \"(A)\", code64 !<``` !=> AAAAAAAA8D8AAAAAAAAAQA== <<< real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R8_a pure subroutine b64_encode_R4_a ( n , code ) !< Encode array numbers to base64 (R4P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=[0._R4P,-32.12_R4P], code=code64) !< print \"(A)\", code64 !<``` !=> AAAAAOF6AMI= <<< real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R4_a pure subroutine b64_encode_I8_a ( n , code ) !< Encode array numbers to base64 (I8P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=[23_I8P,324_I8P,25456656_I8P,2_I8P], code=code64) !< print \"(A)\", code64 !<``` !=> FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA= <<< integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I8_a pure subroutine b64_encode_I4_a ( n , code ) !< Encode array numbers to base64 (I4P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=[2023_I4P,-24_I4P], code=code64) !< print \"(A)\", code64 !<``` !=> 5wcAAOj///8= <<< integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I4_a pure subroutine b64_encode_I2_a ( n , code ) !< Encode array numbers to base64 (I2P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=[-203_I2P,-10_I2P], code=code64) !< print \"(A)\", code64 !<``` !=> Nf/2/w== <<< integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I2_a pure subroutine b64_encode_I1_a ( n , code ) !< Encode array numbers to base64 (I1P). !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(n=[120_I1P,-1_I1P], code=code64) !< print \"(A)\", code64 !<``` !=> eP8= <<< integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I1_a pure subroutine b64_encode_string_a ( s , code ) !< Encode array string to base64. !< !<```fortran !< use befor64 !< use penf !< character(len=:), allocatable :: code64 !< call b64_encode(s=['hello','world'], code=code64) !< print \"(A)\", code64 !<``` !=> aGVsbG93b3JsZA== <<< character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_string_a elemental subroutine b64_decode_R16 ( code , n ) !< Decode a base64 code into a scalar number (R16P). !< !<```fortran !< use befor64 !< use penf !< real(R16P) :: scalar_R16 !< call b64_decode(code='CKwcWmTHYEA=',n=scalar_R16) !< print \"(L1)\", scalar_R16==134.231_R16P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R16 elemental subroutine b64_decode_R8 ( code , n ) !< Decode a base64 code into a scalar number (R8P). !< !<```fortran !< use befor64 !< use penf !< real(R8P) :: scalar_R8 !< call b64_decode(code='AAAAAAAA8D8=',n=scalar_R8) !< print \"(L1)\", scalar_R8==1._R8P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R8 elemental subroutine b64_decode_R4 ( code , n ) !< Decode a base64 code into a scalar number (R4P). !< !<```fortran !< use befor64 !< use penf !< real(R4P) :: scalar_R4 !< call b64_decode(code='AAAAAA==',n=scalar_R4) !< print \"(L1)\", scalar_R4==0._R4P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R4 elemental subroutine b64_decode_I8 ( code , n ) !< Decode a base64 code into a scalar number (I8P). !< !<```fortran !< use befor64 !< use penf !< integer(I8P) :: scalar_I8 !< call b64_decode(code='FwAAAAAAAAA=',n=scalar_I8) !< print \"(L1)\", scalar_I8==23_I8P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I8 elemental subroutine b64_decode_I4 ( code , n ) !< Decode a base64 code into a scalar number (I4P). !< !<```fortran !< use befor64 !< use penf !< integer(I4P) :: scalar_I4 !< call b64_decode(code='5wcAAA==',n=scalar_I4) !< print \"(L1)\", scalar_I4==2023_I4P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I4 elemental subroutine b64_decode_I2 ( code , n ) !< Decode a base64 code into a scalar number (I2P). !< !<```fortran !< use befor64 !< use penf !< integer(I2P) :: scalar_I2 !< call b64_decode(code='Nf8=',n=scalar_I2) !< print \"(L1)\", scalar_I2==-203_I2P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I2 elemental subroutine b64_decode_I1 ( code , n ) !< Decode a base64 code into a scalar number (I1P). !< !<```fortran !< use befor64 !< use penf !< integer(I1P) :: scalar_I1 !< call b64_decode(code='eA==',n=scalar_I1) !< print \"(L1)\", scalar_I1==120_I1P !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I1 elemental subroutine b64_decode_string ( code , s ) !< Decode a base64 code into a scalar string. !< !<```fortran !< use befor64 !< use penf !< character(:), allocatable :: code64 !< code64 = repeat(' ',5) !< call b64_decode(code='aGVsbG8=',s=code64) !< print \"(L1)\", code64=='hello' !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) endsubroutine b64_decode_string pure subroutine b64_decode_R16_a ( code , n ) !< Decode a base64 code into an array numbers (R16P). !< !<```fortran !< use befor64 !< use penf !< real(R16P) :: array_R16(1:2) !< call b64_decode(code='AAAAAABAXkCPwvUoXI8CQA==',n=array_R16) !< print \"(L1)\", str(n=array_R16)==str(n=[121._R16P,2.32_R16P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R16_a pure subroutine b64_decode_R8_a ( code , n ) !< Decode a base64 code into an array numbers (R8P). !< !<```fortran !< use befor64 !< use penf !< real(R8P) :: array_R8(1:2) !< call b64_decode(code='AAAAAAAA8D8AAAAAAAAAQA==',n=array_R8) !< print \"(L1)\", str(n=array_R8)==str(n=[1._R8P,2._R8P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R8_a pure subroutine b64_decode_R4_a ( code , n ) !< Decode a base64 code into an array numbers (R4P). !< !<```fortran !< use befor64 !< use penf !< real(R4P) :: array_R4(1:2) !< call b64_decode(code='AAAAAOF6AMI=',n=array_R4) !< print \"(L1)\", str(n=array_R4)==str(n=[0._R4P,-32.12_R4P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R4_a pure subroutine b64_decode_I8_a ( code , n ) !< Decode a base64 code into an array numbers (I8P). !< !<```fortran !< use befor64 !< use penf !< integer(I8P) :: array_I8(1:4) !< call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=array_I8) !< print \"(L1)\", str(n=array_I8)==str(n=[23_I8P,324_I8P,25456656_I8P,2_I8P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I8_a pure subroutine b64_decode_I4_a ( code , n ) !< Decode a base64 code into an array numbers (I4P). !< !<```fortran !< use befor64 !< use penf !< integer(I4P) :: array_I4(1:2) !< call b64_decode(code='5wcAAOj///8=',n=array_I4) !< print \"(L1)\", str(n=array_I4)==str(n=[2023_I4P,-24_I4P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I4_a pure subroutine b64_decode_I2_a ( code , n ) !< Decode a base64 code into an array numbers (I2P). !< !<```fortran !< use befor64 !< use penf !< integer(I2P) :: array_I2(1:2) !< call b64_decode(code='Nf/2/w==',n=array_I2) !< print \"(L1)\", str(n=array_I2)==str(n=[-203_I2P,-10_I2P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I2_a pure subroutine b64_decode_I1_a ( code , n ) !< Decode a base64 code into an array numbers (I1P). !< !<```fortran !< use befor64 !< use penf !< integer(I1P) :: array_I1(1:2) !< call b64_decode(code='eP8=',n=array_I1) !< print \"(L1)\", str(n=array_I1)==str(n=[120_I1P,-1_I1P]) !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I1_a pure subroutine b64_decode_string_a ( code , s ) !< Decode a base64 code into an array of strings. !< !<```fortran !< use befor64 !< use penf !< character(5) :: array_s(1:2) !< call b64_decode(code='aGVsbG93b3JsZA==',s=array_s) !< print \"(L1)\", array_s(1)//array_s(2)=='helloworld' !<``` !=> T <<< character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) endsubroutine b64_decode_string_a endmodule befor64","tags":"","loc":"sourcefile/befor64.f90.html"},{"title":"penf-doctest-2.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf-doctest-2.f90 Source Code program volatile_doctest use penf use penf call penf_init print FI1P , BYR4P endprogram volatile_doctest","tags":"","loc":"sourcefile/penf-doctest-2.f90.html"},{"title":"penf-doctest-3.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf-doctest-3.f90 Source Code program volatile_doctest use penf use penf integer :: u open ( newunit = u , status = 'scratch' ) call penf_print ( u ) close ( u ) print \"(A)\" , 'done' endprogram volatile_doctest","tags":"","loc":"sourcefile/penf-doctest-3.f90.html"},{"title":"penf-doctest-5.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf-doctest-5.f90 Source Code program volatile_doctest use penf use penf print FI4P , digit ( 100_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf-doctest-5.f90.html"},{"title":"penf-doctest-4.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf-doctest-4.f90 Source Code program volatile_doctest use penf use penf print FI4P , digit ( 100_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf-doctest-4.f90.html"},{"title":"penf-doctest-7.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf-doctest-7.f90 Source Code program volatile_doctest use penf use penf print FI4P , digit ( 100_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf-doctest-7.f90.html"},{"title":"penf-doctest-1.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf-doctest-1.f90 Source Code program volatile_doctest use penf use penf call check_endian print * , endian endprogram volatile_doctest","tags":"","loc":"sourcefile/penf-doctest-1.f90.html"},{"title":"penf-doctest-6.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf-doctest-6.f90 Source Code program volatile_doctest use penf use penf print FI4P , digit ( 100_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf-doctest-6.f90.html"},{"title":"penf_b_size-doctest-6.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-6.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 1._R8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-6.f90.html"},{"title":"penf_b_size-doctest-12.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-12.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 1_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-12.f90.html"},{"title":"penf_b_size-doctest-2.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-2.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , bit_size ( 1._R8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-2.f90.html"},{"title":"penf_b_size-doctest-5.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-5.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 1._R16P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-5.f90.html"},{"title":"penf_b_size-doctest-3.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-3.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , bit_size ( 1._R4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-3.f90.html"},{"title":"penf_b_size-doctest-9.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-9.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 1_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-9.f90.html"},{"title":"penf_b_size-doctest-7.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-7.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 1._R4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-7.f90.html"},{"title":"penf_b_size-doctest-11.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-11.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 1_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-11.f90.html"},{"title":"penf_b_size-doctest-8.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-8.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 'ab' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-8.f90.html"},{"title":"penf_b_size-doctest-1.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-1.f90 Source Code program volatile_doctest use penf_b_size use penf print FI2P , bit_size ( 1._R16P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-1.f90.html"},{"title":"penf_b_size-doctest-4.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-4.f90 Source Code program volatile_doctest use penf_b_size use penf print FI4P , bit_size ( 'ab' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-4.f90.html"},{"title":"penf_b_size-doctest-10.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_b_size-doctest-10.f90 Source Code program volatile_doctest use penf_b_size use penf print FI1P , byte_size ( 1_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_b_size-doctest-10.f90.html"},{"title":"penf_stringify-doctest-41.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-41.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R8P , - 2._R8P ], compact = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-41.f90.html"},{"title":"penf_stringify-doctest-33.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-33.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R16P , 2._R16P ], no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-33.f90.html"},{"title":"penf_stringify-doctest-88.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-88.f90 Source Code program volatile_doctest use penf_stringify use penf print FI8P , bcton ( '0000000000000000000000000000000000000000000000000000000000000001' , knd = 1_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-88.f90.html"},{"title":"penf_stringify-doctest-71.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-71.f90 Source Code program volatile_doctest use penf_stringify use penf print FR16P , cton ( str = '-1.0' , knd = 1._R16P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-71.f90.html"},{"title":"penf_stringify-doctest-60.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-60.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I1P , 2_I1P ], no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-60.f90.html"},{"title":"penf_stringify-doctest-52.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-52.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I4P , 2_I4P ], no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-52.f90.html"},{"title":"penf_stringify-doctest-47.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-47.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I8P , - 2_I8P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-47.f90.html"},{"title":"penf_stringify-doctest-64.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-64.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I8P , nz_pad = 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-64.f90.html"},{"title":"penf_stringify-doctest-7.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-7.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( fm = FR16P , n = 1._R16P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-7.f90.html"},{"title":"penf_stringify-doctest-12.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-12.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( fm = FI2P , n = 1_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-12.f90.html"},{"title":"penf_stringify-doctest-39.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-39.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R8P , - 2._R8P ], separator = '|' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-39.f90.html"},{"title":"penf_stringify-doctest-20.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-20.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-20.f90.html"},{"title":"penf_stringify-doctest-76.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-76.f90 Source Code program volatile_doctest use penf_stringify use penf print FI2P , cton ( str = '-1' , knd = 1_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-76.f90.html"},{"title":"penf_stringify-doctest-11.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-11.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( fm = FI4P , n = 1_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-11.f90.html"},{"title":"penf_stringify-doctest-66.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-66.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I4P , nz_pad = 5 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-66.f90.html"},{"title":"penf_stringify-doctest-62.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-62.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I1P , - 2_I1P ], delimiters = [ '(' , ')' ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-62.f90.html"},{"title":"penf_stringify-doctest-59.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-59.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I1P , - 2_I1P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-59.f90.html"},{"title":"penf_stringify-doctest-53.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-53.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I4P , - 2_I4P ], separator = '|' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-53.f90.html"},{"title":"penf_stringify-doctest-87.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-87.f90 Source Code program volatile_doctest use penf_stringify use penf print FR4P , bcton ( '00000000000000001000000000111111' , knd = 1._R4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-87.f90.html"},{"title":"penf_stringify-doctest-5.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-5.f90 Source Code program volatile_doctest use penf_stringify use penf character ( len = :, kind = UCS4 ), allocatable :: string string = str_ascii ( ASCII_ 'I was ASCII kind, but now I am UCS4' ) print \"(A)\" , string endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-5.f90.html"},{"title":"penf_stringify-doctest-73.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-73.f90 Source Code program volatile_doctest use penf_stringify use penf print FR4P , cton ( str = '-1.0' , knd = 1._R4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-73.f90.html"},{"title":"penf_stringify-doctest-34.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-34.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R16P , - 2._R16P ], separator = '|' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-34.f90.html"},{"title":"penf_stringify-doctest-77.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-77.f90 Source Code program volatile_doctest use penf_stringify use penf print FI1P , cton ( str = '-1' , knd = 1_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-77.f90.html"},{"title":"penf_stringify-doctest-75.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-75.f90 Source Code program volatile_doctest use penf_stringify use penf print FI4P , cton ( str = '-1' , knd = 1_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-75.f90.html"},{"title":"penf_stringify-doctest-78.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-78.f90 Source Code program volatile_doctest use penf_stringify use penf character ( 128 ) :: b b = bstr ( n = 1._R16P ) print \"(A)\" , b ( 17 :) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-78.f90.html"},{"title":"penf_stringify-doctest-26.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-26.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I4P , no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-26.f90.html"},{"title":"penf_stringify-doctest-28.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-28.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I2P , no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-28.f90.html"},{"title":"penf_stringify-doctest-79.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-79.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , bstr ( n = 1._R8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-79.f90.html"},{"title":"penf_stringify-doctest-18.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-18.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R8P , no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-18.f90.html"},{"title":"penf_stringify-doctest-21.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-21.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R4P , no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-21.f90.html"},{"title":"penf_stringify-doctest-58.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-58.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I2P , - 2_I2P ], delimiters = [ '(' , ')' ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-58.f90.html"},{"title":"penf_stringify-doctest-48.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-48.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I8P , 2_I8P ], no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-48.f90.html"},{"title":"penf_stringify-doctest-35.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-35.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R16P , - 2._R16P ], delimiters = [ '(' , ')' ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-35.f90.html"},{"title":"penf_stringify-doctest-17.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-17.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-17.f90.html"},{"title":"penf_stringify-doctest-10.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-10.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( fm = FI8P , n = 1_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-10.f90.html"},{"title":"penf_stringify-doctest-56.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-56.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I2P , 2_I2P ], no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-56.f90.html"},{"title":"penf_stringify-doctest-81.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-81.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , bstr ( n = 1_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-81.f90.html"},{"title":"penf_stringify-doctest-91.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-91.f90 Source Code program volatile_doctest use penf_stringify use penf print FI1P , bcton ( '00000001' , knd = 1_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-91.f90.html"},{"title":"penf_stringify-doctest-4.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-4.f90 Source Code program volatile_doctest use penf_stringify use penf character ( len = :, kind = UCS4 ), allocatable :: string string = str_ascii ( 'I was DEFAULT kind, but now I am UCS4' ) print \"(A)\" , string endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-4.f90.html"},{"title":"penf_stringify-doctest-2.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-2.f90 Source Code program volatile_doctest use penf_stringify use penf character ( len = :, kind = ASCII ), allocatable :: string string = str_ascii ( 'I was ASCII kind and I am still ASCII' ) print \"(A)\" , string endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-2.f90.html"},{"title":"penf_stringify-doctest-84.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-84.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , bstr ( n = 1_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-84.f90.html"},{"title":"penf_stringify-doctest-16.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-16.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R16P , compact = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-16.f90.html"},{"title":"penf_stringify-doctest-13.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-13.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( fm = FI1P , n = 1_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-13.f90.html"},{"title":"penf_stringify-doctest-31.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-31.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-31.f90.html"},{"title":"penf_stringify-doctest-15.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-15.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R16P , no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-15.f90.html"},{"title":"penf_stringify-doctest-49.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-49.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I8P , - 2_I8P ], separator = '|' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-49.f90.html"},{"title":"penf_stringify-doctest-82.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-82.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , bstr ( n = 1_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-82.f90.html"},{"title":"penf_stringify-doctest-23.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-23.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-23.f90.html"},{"title":"penf_stringify-doctest-55.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-55.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I2P , - 2_I2P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-55.f90.html"},{"title":"penf_stringify-doctest-14.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-14.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R16P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-14.f90.html"},{"title":"penf_stringify-doctest-85.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-85.f90 Source Code program volatile_doctest use penf_stringify use penf print FR16P , bcton ( '00000000000000000000000000000000000000000000000000000000000000000000000000000' // & '000000000000000000000000000000000001111111100111111' , knd = 1._R16P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-85.f90.html"},{"title":"penf_stringify-doctest-29.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-29.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-29.f90.html"},{"title":"penf_stringify-doctest-45.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-45.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R4P , - 2._R4P ], delimiters = [ '(' , ')' ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-45.f90.html"},{"title":"penf_stringify-doctest-40.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-40.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R8P , - 2._R8P ], delimiters = [ '(' , ')' ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-40.f90.html"},{"title":"penf_stringify-doctest-37.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-37.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R8P , - 2._R8P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-37.f90.html"},{"title":"penf_stringify-doctest-22.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-22.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R4P , compact = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-22.f90.html"},{"title":"penf_stringify-doctest-70.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-70.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I1P , nz_pad = 3 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-70.f90.html"},{"title":"penf_stringify-doctest-90.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-90.f90 Source Code program volatile_doctest use penf_stringify use penf print FI2P , bcton ( '0000000000000001' , knd = 1_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-90.f90.html"},{"title":"penf_stringify-doctest-57.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-57.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I2P , - 2_I2P ], separator = '|' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-57.f90.html"},{"title":"penf_stringify-doctest-27.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-27.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-27.f90.html"},{"title":"penf_stringify-doctest-46.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-46.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R4P , - 2._R4P ], compact = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-46.f90.html"},{"title":"penf_stringify-doctest-43.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-43.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R4P , 2._R4P ], no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-43.f90.html"},{"title":"penf_stringify-doctest-51.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-51.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I4P , - 2_I4P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-51.f90.html"},{"title":"penf_stringify-doctest-72.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-72.f90 Source Code program volatile_doctest use penf_stringify use penf print FR8P , cton ( str = '-1.0' , knd = 1._R8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-72.f90.html"},{"title":"penf_stringify-doctest-67.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-67.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-67.f90.html"},{"title":"penf_stringify-doctest-65.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-65.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-65.f90.html"},{"title":"penf_stringify-doctest-89.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-89.f90 Source Code program volatile_doctest use penf_stringify use penf print FI4P , bcton ( '00000000000000000000000000000001' , knd = 1_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-89.f90.html"},{"title":"penf_stringify-doctest-80.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-80.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , bstr ( n = 1._R4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-80.f90.html"},{"title":"penf_stringify-doctest-63.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-63.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-63.f90.html"},{"title":"penf_stringify-doctest-38.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-38.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R8P , 2._R8P ], no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-38.f90.html"},{"title":"penf_stringify-doctest-69.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-69.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I1P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-69.f90.html"},{"title":"penf_stringify-doctest-25.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-25.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-25.f90.html"},{"title":"penf_stringify-doctest-44.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-44.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R4P , - 2._R4P ], separator = '|' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-44.f90.html"},{"title":"penf_stringify-doctest-42.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-42.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R4P , - 2._R4P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-42.f90.html"},{"title":"penf_stringify-doctest-19.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-19.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1._R8P , compact = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-19.f90.html"},{"title":"penf_stringify-doctest-50.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-50.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I8P , - 2_I8P ], delimiters = [ '(' , ')' ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-50.f90.html"},{"title":"penf_stringify-doctest-3.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-3.f90 Source Code program volatile_doctest use penf_stringify use penf character ( len = :, kind = ASCII ), allocatable :: string string = str_ascii ( UCS4_ 'I was UCS4 kind, but now I am ASCII' ) print \"(A)\" , string endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-3.f90.html"},{"title":"penf_stringify-doctest-36.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-36.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R16P , - 2._R16P ], compact = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-36.f90.html"},{"title":"penf_stringify-doctest-68.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-68.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , strz ( n = 1_I2P , nz_pad = 3 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-68.f90.html"},{"title":"penf_stringify-doctest-30.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-30.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I1P , no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-30.f90.html"},{"title":"penf_stringify-doctest-1.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-1.f90 Source Code program volatile_doctest use penf_stringify use penf character ( len = :, kind = ASCII ), allocatable :: string string = str_ascii ( 'I was DEFAULT kind, but now I am ASCII' ) print \"(A)\" , string endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-1.f90.html"},{"title":"penf_stringify-doctest-24.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-24.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n =- 1_I8P , no_sign = . true .) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-24.f90.html"},{"title":"penf_stringify-doctest-86.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-86.f90 Source Code program volatile_doctest use penf_stringify use penf print FR8P , bcton ( '0000000000000000000000000000000000000000000000001111000000111111' , knd = 1._R8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-86.f90.html"},{"title":"penf_stringify-doctest-74.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-74.f90 Source Code program volatile_doctest use penf_stringify use penf print FI8P , cton ( str = '-1' , knd = 1_I8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-74.f90.html"},{"title":"penf_stringify-doctest-9.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-9.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( fm = FR4P , n = 1._R4P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-9.f90.html"},{"title":"penf_stringify-doctest-54.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-54.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I4P , - 2_I4P ], delimiters = [ '(' , ')' ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-54.f90.html"},{"title":"penf_stringify-doctest-83.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-83.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , bstr ( n = 1_I2P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-83.f90.html"},{"title":"penf_stringify-doctest-6.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-6.f90 Source Code program volatile_doctest use penf_stringify use penf character ( len = :, kind = UCS4 ), allocatable :: string string = str_ascii ( UCS4_ 'I was UCS4 kind and I am still UCS4' ) print \"(A)\" , string endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-6.f90.html"},{"title":"penf_stringify-doctest-32.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-32.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1._R16P , - 2._R16P ]) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-32.f90.html"},{"title":"penf_stringify-doctest-61.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-61.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( n = [ 1_I1P , - 2_I1P ], separator = '|' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-61.f90.html"},{"title":"penf_stringify-doctest-8.f90 – FoXy","text":"Contents Programs volatile_doctest Source Code penf_stringify-doctest-8.f90 Source Code program volatile_doctest use penf_stringify use penf print \"(A)\" , str ( fm = FR8P , n = 1._R8P ) endprogram volatile_doctest","tags":"","loc":"sourcefile/penf_stringify-doctest-8.f90.html"},{"title":"penf_stringify.F90 – FoXy","text":"Contents Modules penf_stringify Source Code penf_stringify.F90 Source Code !< PENF string-to-number (and viceversa) facility. module penf_stringify !< PENF string-to-number (and viceversa) facility. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf_b_size use penf_global_parameters_variables implicit none private save public :: str_ascii , str_ucs4 public :: str , strz , cton public :: bstr , bcton interface str_ascii !< Convert string of any kind to ASCII string. module procedure str_ascii_default #if defined _ASCII_SUPPORTED && defined _ASCII_NEQ_DEFAULT module procedure str_ascii_ascii #endif #ifdef _UCS4_SUPPORTED module procedure str_ascii_ucs4 #endif endinterface interface str_ucs4 !< Convert string of any kind to UCS4 string. module procedure str_ucs4_default #if defined _ASCII_SUPPORTED && defined _ASCII_NEQ_DEFAULT module procedure str_ucs4_ascii #endif #ifdef _UCS4_SUPPORTED module procedure str_ucs4_ucs4 #endif endinterface interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef _R16P_SUPPORTED strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef _R16P_SUPPORTED str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef _R16P_SUPPORTED ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef _R16P_SUPPORTED bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef _R16P_SUPPORTED bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface contains pure function str_ascii_default ( input ) result ( output ) !< Convert string of default kind to ASCII string. !< !<```fortran !< use penf !< character(len=:, kind=ASCII), allocatable :: string !< string = str_ascii('I was DEFAULT kind, but now I am ASCII') !< print \"(A)\", string !<``` !=> I was DEFAULT kind, but now I am ASCII <<< character ( len =* ), intent ( in ) :: input !< Input string of default kind. character ( len = :, kind = ASCII ), allocatable :: output !< Output string of ASCII kind. output = input endfunction str_ascii_default pure function str_ascii_ascii ( input ) result ( output ) !< Convert string of ASCII kind to ASCII string, just for convenience in sanitize strings. !< !<```fortran !< use penf !< character(len=:, kind=ASCII), allocatable :: string !< string = str_ascii('I was ASCII kind and I am still ASCII') !< print \"(A)\", string !<``` !=> I was ASCII kind and I am still ASCII <<< character ( len =* , kind = ASCII ), intent ( in ) :: input !< Input string of ASCII kind. character ( len = :, kind = ASCII ), allocatable :: output !< Output string of ASCII kind. output = input endfunction str_ascii_ascii pure function str_ascii_ucs4 ( input ) result ( output ) !< Convert string of UCS4 kind to ASCII string. !< !<```fortran !< use penf !< character(len=:, kind=ASCII), allocatable :: string !< string = str_ascii(UCS4_'I was UCS4 kind, but now I am ASCII') !< print \"(A)\", string !<``` !=> I was UCS4 kind, but now I am ASCII <<< character ( len =* , kind = UCS4 ), intent ( in ) :: input !< Input string of UCS4 kind. character ( len = :, kind = ASCII ), allocatable :: output !< Output string of ASCII kind. output = input endfunction str_ascii_ucs4 pure function str_ucs4_default ( input ) result ( output ) !< Convert string of default kind to UCS4 string. !< !<```fortran !< use penf !< character(len=:, kind=UCS4), allocatable :: string !< string = str_ascii('I was DEFAULT kind, but now I am UCS4') !< print \"(A)\", string !<``` !=> I was DEFAULT kind, but now I am UCS4 <<< character ( len =* ), intent ( in ) :: input !< Input string of default kind. character ( len = :, kind = UCS4 ), allocatable :: output !< Output string of UCS4 kind. output = input endfunction str_ucs4_default pure function str_ucs4_ascii ( input ) result ( output ) !< Convert string of ASCII kind to UCS4 string. !< !<```fortran !< use penf !< character(len=:, kind=UCS4), allocatable :: string !< string = str_ascii(ASCII_'I was ASCII kind, but now I am UCS4') !< print \"(A)\", string !<``` !=> I was ASCII kind, but now I am UCS4 <<< character ( len =* , kind = ASCII ), intent ( in ) :: input !< Input string of ASCII kind. character ( len = :, kind = UCS4 ), allocatable :: output !< Output string of UCS4 kind. output = input endfunction str_ucs4_ascii pure function str_ucs4_ucs4 ( input ) result ( output ) !< Convert string of UCS4 kind to UCS4 string, just for convenience in sanitize strings. !< !<```fortran !< use penf !< character(len=:, kind=UCS4), allocatable :: string !< string = str_ascii(UCS4_'I was UCS4 kind and I am still UCS4') !< print \"(A)\", string !<``` !=> I was UCS4 kind and I am still UCS4 <<< character ( len =* , kind = UCS4 ), intent ( in ) :: input !< Input string of UCS4 kind. character ( len = :, kind = UCS4 ), allocatable :: output !< Output string of UCS4 kind. output = input endfunction str_ucs4_ucs4 elemental function strf_R16P ( fm , n ) result ( str ) !< Convert real to string. !< !<```fortran !< use penf !< print \"(A)\", str(fm=FR16P, n=1._R16P) !<``` !=> 0.100000000000000000000000000000000E+0001 <<< character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !< Convert real to string. !< !<```fortran !< use penf !< print \"(A)\", str(fm=FR8P, n=1._R8P) !<``` !=> 0.100000000000000E+001 <<< character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !< Convert real to string. !< !<```fortran !< use penf !< print \"(A)\", str(fm=FR4P, n=1._R4P) !<``` !=> 0.100000E+01 <<< character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !< Convert integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(fm=FI8P, n=1_I8P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !< Convert integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(fm=FI4P, n=1_I4P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !< Convert integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(fm=FI2P, n=1_I2P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !< Convert integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(fm=FI1P, n=1_I1P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I1P elemental function str_R16P ( n , no_sign , compact ) result ( str ) !< Convert real to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R16P) !<``` !=> -0.100000000000000000000000000000000E+0001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R16P, no_sign=.true.) !<``` !=> 0.100000000000000000000000000000000E+0001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R16P, compact=.true.) !<``` !=> -0.1E+1 <<< real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R16P elemental function str_R8P ( n , no_sign , compact ) result ( str ) !< Convert real to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R8P) !<``` !=> -0.100000000000000E+001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R8P, no_sign=.true.) !<``` !=> 0.100000000000000E+001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R8P, compact=.true.) !<``` !=> -0.1E+1 <<< real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R8P elemental function str_R4P ( n , no_sign , compact ) result ( str ) !< Convert real to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R4P) !<``` !=> -0.100000E+01 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R4P, no_sign=.true.) !<``` !=> 0.100000E+01 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1._R4P, compact=.true.) !<``` !=> -0.1E+1 <<< real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !< Convert integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I8P) !<``` !=> -1 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I8P, no_sign=.true.) !<``` !=> 1 <<< integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !< Converting integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I4P) !<``` !=> -1 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I4P, no_sign=.true.) !<``` !=> 1 <<< integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !< Convert integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I2P) !<``` !=> -1 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I2P, no_sign=.true.) !<``` !=> 1 <<< integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !< Convert integer to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I1P) !<``` !=> -1 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=-1_I1P, no_sign=.true.) !<``` !=> 1 <<< integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I1P elemental function str_bol ( n ) result ( str ) !< Convert logical to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=.true.) !<``` !=> T <<< logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. write ( str , '(L1)' ) n endfunction str_bol pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Converting real array to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R16P, -2._R16P]) !<``` !=> +0.100000000000000000000000000000000E+0001,-0.200000000000000000000000000000000E+0001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R16P, 2._R16P], no_sign=.true.) !<``` !=> 0.100000000000000000000000000000000E+0001,0.200000000000000000000000000000000E+0001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R16P, -2._R16P], separator='|') !<``` !=> +0.100000000000000000000000000000000E+0001|-0.200000000000000000000000000000000E+0001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R16P, -2._R16P], delimiters=['(', ')']) !<``` !=> (+0.100000000000000000000000000000000E+0001,-0.200000000000000000000000000000000E+0001) <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R16P, -2._R16P], compact=.true.) !<``` !=> +0.1E+1,-0.2E+1 <<< real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Convert real array to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R8P, -2._R8P]) !<``` !=> +0.100000000000000E+001,-0.200000000000000E+001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R8P, 2._R8P], no_sign=.true.) !<``` !=> 0.100000000000000E+001,0.200000000000000E+001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R8P, -2._R8P], separator='|') !<``` !=> +0.100000000000000E+001|-0.200000000000000E+001 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R8P, -2._R8P], delimiters=['(', ')']) !<``` !=> (+0.100000000000000E+001,-0.200000000000000E+001) <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R8P, -2._R8P], compact=.true.) !<``` !=> +0.1E+1,-0.2E+1 <<< real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Convert real array to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R4P, -2._R4P]) !<``` !=> +0.100000E+01,-0.200000E+01 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R4P, 2._R4P], no_sign=.true.) !<``` !=> 0.100000E+01,0.200000E+01 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R4P, -2._R4P], separator='|') !<``` !=> +0.100000E+01|-0.200000E+01 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R4P, -2._R4P], delimiters=['(', ')']) !<``` !=> (+0.100000E+01,-0.200000E+01) <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1._R4P, -2._R4P], compact=.true.) !<``` !=> +0.1E+1,-0.2E+1 <<< real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I8P, -2_I8P]) !<``` !=> +1,-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I8P, 2_I8P], no_sign=.true.) !<``` !=> 1,2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I8P, -2_I8P], separator='|') !<``` !=> +1|-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I8P, -2_I8P], delimiters=['(', ')']) !<``` !=> (+1,-2) <<< integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I4P, -2_I4P]) !<``` !=> +1,-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I4P, 2_I4P], no_sign=.true.) !<``` !=> 1,2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I4P, -2_I4P], separator='|') !<``` !=> +1|-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I4P, -2_I4P], delimiters=['(', ')']) !<``` !=> (+1,-2) <<< integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I2P, -2_I2P]) !<``` !=> +1,-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I2P, 2_I2P], no_sign=.true.) !<``` !=> 1,2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I2P, -2_I2P], separator='|') !<``` !=> +1|-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I2P, -2_I2P], delimiters=['(', ')']) !<``` !=> (+1,-2) <<< integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I1P, -2_I1P]) !<``` !=> +1,-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I1P, 2_I1P], no_sign=.true.) !<``` !=> 1,2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I1P, -2_I1P], separator='|') !<``` !=> +1|-2 <<< !< !<```fortran !< use penf !< print \"(A)\", str(n=[1_I1P, -2_I1P], delimiters=['(', ')']) !<``` !=> (+1,-2) <<< integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I1P pure subroutine compact_real_string ( string ) !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !< !< @note No need to add doctest: this is tested by a lot of doctests of other TBPs. character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif endsubroutine compact_real_string elemental function strz_I8P ( n , nz_pad ) result ( str ) !< Converting integer to string, prefixing with the right number of zeros. !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I8P) !<``` !=> 0000000000000000001 <<< !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I8P, nz_pad=5) !<``` !=> 00001 <<< integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I4P) !<``` !=> 0000000001 <<< !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I4P, nz_pad=5) !<``` !=> 00001 <<< integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I2P) !<``` !=> 00001 <<< !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I2P, nz_pad=3) !<``` !=> 001 <<< integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I1P) !<``` !=> 001 <<< !< !<```fortran !< use penf !< print \"(A)\", strz(n=1_I1P, nz_pad=3) !<``` !=> 001 <<< integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !< Convert string to real. !< !<```fortran !< use penf !< print FR16P, cton(str='-1.0', knd=1._R16P) !<``` !=> -0.100000000000000000000000000000000E+0001 <<< character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !< Convert string to real. !< !<```fortran !< use penf !< print FR8P, cton(str='-1.0', knd=1._R8P) !<``` !=> -0.100000000000000E+001 <<< character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !< Convert string to real. !< !<```fortran !< use penf !< print FR4P, cton(str='-1.0', knd=1._R4P) !<``` !=> -0.100000E+01 <<< character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. !< !<```fortran !< use penf !< print FI8P, cton(str='-1', knd=1_I8P) !<``` !=> -1 <<< character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. !< !<```fortran !< use penf !< print FI4P, cton(str='-1', knd=1_I4P) !<``` !=> -1 <<< character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. !< !<```fortran !< use penf !< print FI2P, cton(str='-1', knd=1_I2P) !<``` !=> -1 <<< character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. !< !<```fortran !< use penf !< print FI1P, cton(str='-1', knd=1_I1P) !<``` !=> -1 <<< character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !< !<```fortran !< use penf !< character(128) :: b !< b = bstr(n=1._R16P) !< print \"(A)\", b(17:) !<``` !=> 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111100111111 <<< real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. integer ( I1P ) :: buffer ( 16 ) !< Transfer buffer. buffer = transfer ( n , buffer ) write ( bstr , '(16B8.8)' ) buffer endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !< !<```fortran !< use penf !< print \"(A)\", bstr(n=1._R8P) !<``` !=> 0000000000000000000000000000000000000000000000001111000000111111 <<< real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. integer ( I1P ) :: buffer ( 8 ) !< Transfer buffer. buffer = transfer ( n , buffer ) write ( bstr , '(8B8.8)' ) buffer endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !< !<```fortran !< use penf !< print \"(A)\", bstr(n=1._R4P) !<``` !=> 00000000000000001000000000111111 <<< real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. integer ( I1P ) :: buffer ( 4 ) !< Transfer buffer. buffer = transfer ( n , buffer ) write ( bstr , '(4B8.8)' ) buffer endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !< !<```fortran !< use penf !< print \"(A)\", bstr(n=1_I8P) !<``` !=> 0000000000000000000000000000000000000000000000000000000000000001 <<< integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B64.64)' ) n endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !< !<```fortran !< use penf !< print \"(A)\", bstr(n=1_I4P) !<``` !=> 00000000000000000000000000000001 <<< integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B32.32)' ) n endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !< !<```fortran !< use penf !< print \"(A)\", bstr(n=1_I2P) !<``` !=> 0000000000000001 <<< integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B16.16)' ) n endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !< !<```fortran !< use penf !< print \"(A)\", bstr(n=1_I1P) !<``` !=> 00000001 <<< integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B8.8)' ) n endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !< Convert bit-string to real. !< !<```fortran !< use penf !< print FR16P, bcton('00000000000000000000000000000000000000000000000000000000000000000000000000000'//& !<                    '000000000000000000000000000000000001111111100111111', knd=1._R16P) !<``` !=> 0.100000000000000000000000000000000E+0001 <<< character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. integer ( I1P ) :: buffer ( 16 ) !< Transfer buffer. read ( bstr , '(16B8.8)' ) buffer n = transfer ( buffer , n ) endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !< Convert bit-string to real. !< !<```fortran !< use penf !< print FR8P, bcton('0000000000000000000000000000000000000000000000001111000000111111', knd=1._R8P) !<``` !=> 0.100000000000000E+001 <<< character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. integer ( I1P ) :: buffer ( 8 ) !< Transfer buffer. read ( bstr , '(8B8.8)' ) buffer n = transfer ( buffer , n ) endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !< Convert bit-string to real. !< !<```fortran !< use penf !< print FR4P, bcton('00000000000000001000000000111111', knd=1._R4P) !<``` !=> 0.100000E+01 <<< character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. integer ( I1P ) :: buffer ( 4 ) !< Transfer buffer. read ( bstr , '(4B8.8)' ) buffer n = transfer ( buffer , n ) endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. !< !<```fortran !< use penf !< print FI8P, bcton('0000000000000000000000000000000000000000000000000000000000000001', knd=1_I8P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. !< !<```fortran !< use penf !< print FI4P, bcton('00000000000000000000000000000001', knd=1_I4P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. !< !<```fortran !< use penf !< print FI2P, bcton('0000000000000001', knd=1_I2P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. !< !<```fortran !< use penf !< print FI1P, bcton('00000001', knd=1_I1P) !<``` !=> 1 <<< character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I1P endmodule penf_stringify","tags":"","loc":"sourcefile/penf_stringify.f90.html"},{"title":"penf.F90 – FoXy","text":"Contents Modules penf Source Code penf.F90 Source Code !< Portability Environment for Fortran poor people. module penf !< Portability Environment for Fortran poor people. use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str_ascii , str_ucs4 , str , strz , cton , bstr , bcton implicit none private save ! global parameters and variables public :: endianL , endianB , endian , is_initialized public :: ASCII , UCS4 , CK public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16P public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8P public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4P public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , ZeroR_P public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: CHARACTER_KINDS_LIST , REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! bit/byte size functions public :: bit_size , byte_size ! stringify facility public :: str_ascii , str_ucs4 public :: str , strz , cton public :: bstr , bcton ! miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print integer , protected :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). logical , protected :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface contains ! public procedures subroutine check_endian () !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !< !<```fortran !< use penf !< call check_endian !< print *, endian !<``` !=> 1 <<< if ( is_little_endian ()) then endian = endianL else endian = endianB endif contains pure function is_little_endian () result ( is_little ) !< Check if the type of the bit ordering of the running architecture is little endian. logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) endfunction is_little_endian endsubroutine check_endian subroutine penf_init () !< Initialize PENF's variables that are not initialized into the definition specification. !< !<```fortran !< use penf !< call penf_init !< print FI1P, BYR4P !<``` !=> 4 <<< call check_endian BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P is_initialized = . true . endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !< Print to the specified unit the PENF's environment data. !< !<```fortran !< use penf !< integer :: u !< open(newunit=u, status='scratch') !< call penf_print(u) !< close(u) !< print \"(A)\", 'done' !<``` !=> done <<< integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Character kind:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  ASCII: ' // str ( n = ASCII ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  UCS4:  ' // str ( n = UCS4 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  CK:    ' // str ( n = CK ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R_P:  ' // str ( n = R_P ) // ',' // FR_P // ',' // str ( n = DR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R_P:  ' // str ( n = MinR_P ) // ',' // str ( n = MaxR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  R_P:  ' // str ( n = BIR_P ) // '/' // str ( n = BYR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Smallest reals' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  smallR16P: ' // str ( smallR16P , . true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  smallR8P:  ' // str ( smallR8P , . true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  smallR4P:  ' // str ( smallR4P , . true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  smallR_P:  ' // str ( smallR_P , . true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // 'Machine zero' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  ZeroR16P: ' // str ( ZeroR16P , . true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  ZeroR8P:  ' // str ( ZeroR8P , . true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  ZeroR4P:  ' // str ( ZeroR4P , . true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '  ZeroR_P:  ' // str ( ZeroR_P , . true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine penf_print ! private procedures elemental function digit_I8 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. !< !<```fortran !< use penf !< print FI4P, digit(100_I8P) !<``` !=> 3 <<< integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. !< !<```fortran !< use penf !< print FI4P, digit(100_I4P) !<``` !=> 3 <<< integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. !< !<```fortran !< use penf !< print FI4P, digit(100_I2P) !<``` !=> 3 <<< integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. !< !<```fortran !< use penf !< print FI4P, digit(100_I1P) !<``` !=> 3 <<< integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I1 endmodule penf","tags":"","loc":"sourcefile/penf.f90.html"},{"title":"penf_global_parameters_variables.F90 – FoXy","text":"Contents Modules penf_global_parameters_variables Source Code penf_global_parameters_variables.F90 Source Code !< PENF global parameters and variables. module penf_global_parameters_variables !< PENF global parameters and variables. !< !< @note All module defined entities are public. implicit none public save integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. ! portable kind parameters #ifdef _ASCII_SUPPORTED integer , parameter :: ASCII = selected_char_kind ( 'ascii' ) !< ASCII character set kind. #else integer , parameter :: ASCII = selected_char_kind ( 'default' ) !< ASCII character set kind defined as default set. #endif #ifdef _UCS4_SUPPORTED integer , parameter :: UCS4 = selected_char_kind ( 'iso_10646' ) !< Unicode character set kind. #else integer , parameter :: UCS4 = selected_char_kind ( 'default' ) !< Unicode character set kind defined as default set. #endif #if defined _CK_IS_DEFAULT integer , parameter :: CK = selected_char_kind ( 'default' ) !< Default kind character. #elif defined _CK_IS_ASCII integer , parameter :: CK = ASCII !< Default kind character. #elif defined _CK_IS_UCS4 integer , parameter :: CK = UCS4 !< Default kind character. #else integer , parameter :: CK = selected_char_kind ( 'default' ) !< Default kind character. #endif #ifdef _R16P_SUPPORTED integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. #if defined _R_P_IS_R16P integer , parameter :: R_P = R16P !< Default real precision. #elif defined _R_P_IS_R8P integer , parameter :: R_P = R8P !< Default real precision. #elif defined _R_P_IS_R4P integer , parameter :: R_P = R4P !< Default real precision. #else integer , parameter :: R_P = R8P !< Default real precision. #endif integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. ! format parameters #ifdef _R16P_SUPPORTED character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. #if defined _R_P_IS_R16P character ( * ), parameter :: FR_P = FR16P !< Output format for kind=R_P real. #elif defined _R_P_IS_R8P character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. #elif defined _R_P_IS_R4P character ( * ), parameter :: FR_P = FR4P !< Output format for kind=R_P real. #else character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. #endif character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. ! length (number of digits) of formatted numbers #ifdef _R16P_SUPPORTED integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. #if defined _R_P_IS_R16P integer , parameter :: DR_P = DR16P !< Number of digits of output format FR_P. #elif defined _R_P_IS_R8P integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. #elif defined _R_P_IS_R4P integer , parameter :: DR_P = DR4P !< Number of digits of output format FR_P. #else integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. #endif integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. ! list of kinds integer , parameter :: CHARACTER_KINDS_LIST ( 1 : 3 ) = [ ASCII , UCS4 , CK ] !< List of character kinds. integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. ! minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = - huge ( 1._R_P ) !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = huge ( 1._R_P ) !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = - huge ( 1_I_P ) !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = huge ( 1_I_P ) !< Maximum value of kind=I_P integer. ! real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = tiny ( 1._R_P ) !< Smallest representable value of kind=R_P real. ! smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16P = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8P = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4P = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: ZeroR_P = nearest ( 1._R_P , 1._R_P ) - & nearest ( 1._R_P , - 1._R_P ) !< Smallest representable difference of kind=R_P real. ! bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. endmodule penf_global_parameters_variables","tags":"","loc":"sourcefile/penf_global_parameters_variables.f90.html"},{"title":"penf_b_size.F90 – FoXy","text":"Contents Modules penf_b_size Source Code penf_b_size.F90 Source Code !< PENF bit/byte size functions. module penf_b_size !< PENF bit/byte size functions. use penf_global_parameters_variables implicit none private save public :: bit_size , byte_size interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef _R16P_SUPPORTED bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef _R16P_SUPPORTED byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface contains elemental function bit_size_R16P ( i ) result ( bits ) !< Compute the number of bits of a real variable. !< !<```fortran !< use penf !< print FI2P, bit_size(1._R16P) !<``` !=> 128 <<< real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !< Compute the number of bits of a real variable. !< !<```fortran !< use penf !< print FI1P, bit_size(1._R8P) !<``` !=> 64 <<< real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !< Compute the number of bits of a real variable. !< !<```fortran !< use penf !< print FI1P, bit_size(1._R4P) !<``` !=> 32 <<< real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !< Compute the number of bits of a character variable. !< !<```fortran !< use penf !< print FI4P, bit_size('ab') !<``` !=> 16 <<< character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P endfunction bit_size_chr elemental function byte_size_R16P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. !< !<```fortran !< use penf !< print FI1P, byte_size(1._R16P) !<``` !=> 16 <<< real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. !< !<```fortran !< use penf !< print FI1P, byte_size(1._R8P) !<``` !=> 8 <<< real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. !< !<```fortran !< use penf !< print FI1P, byte_size(1._R4P) !<``` !=> 4 <<< real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !< Compute the number of bytes of a character variable. !< !<```fortran !< use penf !< print FI1P, byte_size('ab') !<``` !=> 2 <<< character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. bytes = bit_size ( i ) / 8_I4P endfunction byte_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. !< !<```fortran !< use penf !< print FI1P, byte_size(1_I8P) !<``` !=> 8 <<< integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. !< !<```fortran !< use penf !< print FI1P, byte_size(1_I4P) !<``` !=> 4 <<< integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. !< !<```fortran !< use penf !< print FI1P, byte_size(1_I2P) !<``` !=> 2 <<< integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. !< !<```fortran !< use penf !< print FI1P, byte_size(1_I1P) !<``` !=> 1 <<< integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I1P endmodule penf_b_size","tags":"","loc":"sourcefile/penf_b_size.f90.html"},{"title":"xml_file – FoXy ","text":"type, public :: xml_file Contents Finalization Procedures finalize Type-Bound Procedures free parse content stringify add_tag delete_tag Finalization Procedures final :: finalize private subroutine finalize(file) Arguments Type Intent Optional Attributes Name type( xml_file ), intent(inout) :: file Type-Bound Procedures procedure, public :: free private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self procedure, public :: parse private subroutine parse(self, string, filename) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self character(len=*), intent(in), optional :: string character(len=*), intent(in), optional :: filename procedure, public :: content private pure function content(self, name) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self character(len=*), intent(in) :: name Return Value character(len=:),\n  allocatable procedure, public :: stringify private pure function stringify(self) result(string) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self Return Value character(len=:),\n  allocatable procedure, public :: add_tag private elemental subroutine add_tag(self, tag) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self type( xml_tag ), intent(in) :: tag procedure, public :: delete_tag private elemental subroutine delete_tag(self, name) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self character(len=*), intent(in) :: name","tags":"","loc":"type/xml_file.html"},{"title":"xml_tag – FoXy ","text":"type, public :: xml_tag Contents Constructor xml_tag Type-Bound Procedures add_attributes attributes get_content delete_attributes delete_content end_tag free is_attribute_present is_parsed name parse self_closing_tag set start_tag stringify write assignment(=) Constructor public interface xml_tag private pure function create_tag_flat(name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, indent, is_content_indented, is_self_closing) result(tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: attribute (1:) character(len=*), intent(in), optional :: attributes (1:,1:) character(len=*), intent(in), optional :: attributes_stream logical, intent(in), optional :: sanitize_attributes_value character(len=*), intent(in), optional :: content integer(kind=I4P), intent(in), optional :: indent logical, intent(in), optional :: is_content_indented logical, intent(in), optional :: is_self_closing Return Value type( xml_tag ) private pure function create_tag_nested(name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, indent, is_content_indented) result(tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type( xml_tag ), intent(in) :: content character(len=*), intent(in), optional :: attribute (1:) character(len=*), intent(in), optional :: attributes (1:,1:) character(len=*), intent(in), optional :: attributes_stream logical, intent(in), optional :: sanitize_attributes_value integer(kind=I4P), intent(in), optional :: indent logical, intent(in), optional :: is_content_indented Return Value type( xml_tag ) Type-Bound Procedures generic, public :: add_attributes => add_single_attribute, add_multiple_attributes, add_stream_attributes private pure subroutine add_single_attribute(self, attribute, sanitize_value) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self character(len=*), intent(in) :: attribute (1:) logical, intent(in), optional :: sanitize_value private pure subroutine add_multiple_attributes(self, attributes, sanitize_values) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self character(len=*), intent(in) :: attributes (1:,1:) logical, intent(in), optional :: sanitize_values private pure subroutine add_stream_attributes(self, attributes_stream, sanitize_values) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self character(len=*), intent(in) :: attributes_stream logical, intent(in), optional :: sanitize_values procedure, public, pass(self) :: attributes private pure function attributes(self) result(att_) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self Return Value character(len=:),\n  allocatable procedure, public, pass(self) :: get_content private pure subroutine get_content(self, name, content) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self character(len=*), intent(in) :: name character(len=:), intent(out), allocatable :: content generic, public :: delete_attributes => delete_single_attribute, delete_multiple_attributes private pure subroutine delete_single_attribute(self, name) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self character(len=*), intent(in) :: name private pure subroutine delete_multiple_attributes(self, name) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self character(len=*), intent(in) :: name (1:) procedure, public, pass(self) :: delete_content private pure subroutine delete_content(self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self procedure, public, pass(self) :: end_tag private pure function end_tag(self, is_indented) result(tag_) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self logical, intent(in), optional :: is_indented Return Value character(len=:),\n  allocatable procedure, public, pass(self) :: free private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self procedure, public, pass(self) :: is_attribute_present private pure function is_attribute_present(self, name) result(is_present) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self character(len=*), intent(in) :: name Return Value logical procedure, public, pass(self) :: is_parsed private elemental function is_parsed(self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self Return Value logical procedure, public, pass(self) :: name private pure function name(self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self Return Value character(len=:),\n  allocatable procedure, public, pass(self) :: parse private elemental subroutine parse(self, source, tstart, tend) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self character(len=*), intent(in) :: source integer(kind=I4P), intent(out), optional :: tstart integer(kind=I4P), intent(out), optional :: tend procedure, public, pass(self) :: self_closing_tag private pure function self_closing_tag(self, is_indented) result(tag_) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self logical, intent(in), optional :: is_indented Return Value character(len=:),\n  allocatable procedure, public, pass(self) :: set private pure subroutine set(self, name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, indent, is_content_indented, is_self_closing) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self character(len=*), intent(in), optional :: name character(len=*), intent(in), optional :: attribute (1:) character(len=*), intent(in), optional :: attributes (1:,1:) character(len=*), intent(in), optional :: attributes_stream logical, intent(in), optional :: sanitize_attributes_value character(len=*), intent(in), optional :: content integer(kind=I4P), intent(in), optional :: indent logical, intent(in), optional :: is_content_indented logical, intent(in), optional :: is_self_closing procedure, public, pass(self) :: start_tag private pure function start_tag(self, is_indented) result(tag_) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self logical, intent(in), optional :: is_indented Return Value character(len=:),\n  allocatable procedure, public, pass(self) :: stringify private pure function stringify(self, is_indented, is_content_indented, only_start, only_content, only_end) result(stringed) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self logical, intent(in), optional :: is_indented logical, intent(in), optional :: is_content_indented logical, intent(in), optional :: only_start logical, intent(in), optional :: only_content logical, intent(in), optional :: only_end Return Value character(len=:),\n  allocatable procedure, public, pass(self) :: write => write_tag private subroutine write_tag(self, unit, is_indented, is_content_indented, form, end_record, only_start, only_content, only_end, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self integer(kind=I4P), intent(in) :: unit logical, intent(in), optional :: is_indented logical, intent(in), optional :: is_content_indented character(len=*), intent(in), optional :: form character(len=*), intent(in), optional :: end_record logical, intent(in), optional :: only_start logical, intent(in), optional :: only_content logical, intent(in), optional :: only_end integer(kind=I4P), intent(out), optional :: iostat character(len=*), intent(out), optional :: iomsg generic, public :: assignment(=) => assign_tag private elemental subroutine assign_tag(lhs, rhs) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs type( xml_tag ), intent(in) :: rhs","tags":"","loc":"type/xml_tag.html"},{"title":"string – FoXy ","text":"type, public :: string Contents Type-Bound Procedures adjustl adjustr count index len len_trim repeat scan trim verify basedir basename camelcase capitalize chars decode encode escape extension fill free glob insert join lower partition read_file read_line read_lines replace reverse search slice snakecase split split_chunked startcase strip swapcase tempname to_number unescape unique upper write_file write_line write_lines end_with is_allocated is_digit is_integer is_lower is_number is_real is_upper start_with assignment(=) operator(//) operator(.cat.) operator(==) operator(/=) operator(<) operator(<=) operator(>=) operator(>) Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl private elemental function sadjustl(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: adjustr => sadjustr private elemental function sadjustr(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: count => scount private elemental function scount(self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: substring logical, intent(in), optional :: ignore_isolated Return Value integer generic, public :: index => sindex_string_string, sindex_string_character public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer procedure, public, pass(self) :: len => slen public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer procedure, public, pass(self) :: len_trim => slen_trim public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer generic, public :: repeat => srepeat_string_string, srepeat_character_string public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: ncopies Return Value type( string ) private elemental function srepeat_character_string(rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring integer, intent(in) :: ncopies Return Value type( string ) generic, public :: scan => sscan_string_string, sscan_string_character public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer procedure, public, pass(self) :: trim => strim public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: verify => sverify private elemental function sverify(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer procedure, public, pass(self) :: basedir private elemental function basedir(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in), optional :: sep Return Value type( string ) procedure, public, pass(self) :: basename private elemental function basename(self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in), optional :: sep character(kind=CK,len=*), intent(in), optional :: extension logical, intent(in), optional :: strip_last_extension Return Value type( string ) procedure, public, pass(self) :: camelcase private elemental function camelcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in), optional :: sep Return Value type( string ) procedure, public, pass(self) :: capitalize private elemental function capitalize(self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: chars private pure function chars(self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable procedure, public, pass(self) :: decode private elemental function decode(self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: codec Return Value type( string ) procedure, public, pass(self) :: encode private elemental function encode(self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: codec Return Value type( string ) procedure, public, pass(self) :: escape private elemental function escape(self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=1), intent(in) :: to_escape character(kind=CK,len=*), intent(in), optional :: esc Return Value type( string ) procedure, public, pass(self) :: extension private elemental function extension(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: fill private elemental function fill(self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: width logical, intent(in), optional :: right character(kind=CK,len=1), intent(in), optional :: filling_char Return Value type( string ) procedure, public, pass(self) :: free private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self generic, public :: glob => glob_character, glob_string private subroutine glob_character(self, pattern, list) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: pattern character(len=:), intent(out), allocatable :: list (:) private subroutine glob_string(self, pattern, list) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: pattern type( string ), intent(out), allocatable :: list (:) generic, public :: insert => insert_string, insert_character private elemental function insert_string(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: substring integer, intent(in) :: pos Return Value type( string ) private elemental function insert_character(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: substring integer, intent(in) :: pos Return Value type( string ) generic, public :: join => join_strings, join_characters private pure function join_strings(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: array (1:) character(kind=CK,len=*), intent(in), optional :: sep Return Value type( string ) private pure function join_characters(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: array (1:) character(kind=CK,len=*), intent(in), optional :: sep Return Value type( string ) procedure, public, pass(self) :: lower private elemental function lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: partition private pure function partition(self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in), optional :: sep Return Value type( string )\n  (1:3) procedure, public, pass(self) :: read_file private subroutine read_file(self, file, is_fast, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self character(len=*), intent(in) :: file logical, intent(in), optional :: is_fast character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg procedure, public, pass(self) :: read_line private subroutine read_line(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg procedure, public, pass(self) :: read_lines private subroutine read_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg procedure, public, pass(self) :: replace private elemental function replace(self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: old character(kind=CK,len=*), intent(in) :: new integer, intent(in), optional :: count Return Value type( string ) procedure, public, pass(self) :: reverse private elemental function reverse(self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: search private function search(self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: tag_start character(kind=CK,len=*), intent(in) :: tag_end type( string ), intent(in), optional :: in_string character(kind=CK,len=*), intent(in), optional :: in_character integer, intent(out), optional :: istart integer, intent(out), optional :: iend Return Value type( string ) procedure, public, pass(self) :: slice private pure function slice(self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: istart integer, intent(in) :: iend Return Value character(kind=CK,len=:),\n  allocatable procedure, public, pass(self) :: snakecase private elemental function snakecase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in), optional :: sep Return Value type( string ) procedure, public, pass(self) :: split private pure subroutine split(self, tokens, sep, max_tokens) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(out), allocatable :: tokens (:) character(kind=CK,len=*), intent(in), optional :: sep integer, intent(in), optional :: max_tokens procedure, public, pass(self) :: split_chunked private pure subroutine split_chunked(self, tokens, chunks, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(out), allocatable :: tokens (:) integer, intent(in) :: chunks character(kind=CK,len=*), intent(in), optional :: sep procedure, public, pass(self) :: startcase private elemental function startcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in), optional :: sep Return Value type( string ) procedure, public, pass(self) :: strip private elemental function strip(self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self logical, intent(in), optional :: remove_nulls Return Value type( string ) procedure, public, pass(self) :: swapcase private elemental function swapcase(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: tempname private function tempname(self, is_file, prefix, path) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self logical, intent(in), optional :: is_file character(len=*), intent(in), optional :: prefix character(len=*), intent(in), optional :: path Return Value character(len=:),\n  allocatable generic, public :: to_number => to_integer_I1P, to_integer_I2P, to_integer_I4P, to_integer_I8P, to_real_R4P, to_real_R8P private elemental function to_integer_I1P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer(kind=I1P), intent(in) :: kind Return Value integer(kind=I1P) private elemental function to_integer_I2P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer(kind=I2P), intent(in) :: kind Return Value integer(kind=I2P) private elemental function to_integer_I4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer(kind=I4P), intent(in) :: kind Return Value integer(kind=I4P) private elemental function to_integer_I8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer(kind=I8P), intent(in) :: kind Return Value integer(kind=I8P) private elemental function to_real_R4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self real(kind=R4P), intent(in) :: kind Return Value real(kind=R4P) private elemental function to_real_R8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self real(kind=R8P), intent(in) :: kind Return Value real(kind=R8P) procedure, public, pass(self) :: unescape private elemental function unescape(self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=1), intent(in) :: to_unescape character(kind=CK,len=*), intent(in), optional :: unesc Return Value type( string ) procedure, public, pass(self) :: unique private elemental function unique(self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in), optional :: substring Return Value type( string ) procedure, public, pass(self) :: upper private elemental function upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public, pass(self) :: write_file private subroutine write_file(self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: file character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg procedure, public, pass(self) :: write_line private subroutine write_line(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg procedure, public, pass(self) :: write_lines private subroutine write_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg procedure, public, pass(self) :: end_with private elemental function end_with(self, suffix, start, end, ignore_null_eof) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: suffix integer, intent(in), optional :: start integer, intent(in), optional :: end logical, intent(in), optional :: ignore_null_eof Return Value logical procedure, public, pass(self) :: is_allocated private elemental function is_allocated(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value logical procedure, public, pass(self) :: is_digit private elemental function is_digit(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value logical procedure, public, pass(self) :: is_integer private elemental function is_integer(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self logical, intent(in), optional :: allow_spaces Return Value logical procedure, public, pass(self) :: is_lower private elemental function is_lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value logical procedure, public, pass(self) :: is_number private elemental function is_number(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self logical, intent(in), optional :: allow_spaces Return Value logical procedure, public, pass(self) :: is_real private elemental function is_real(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self logical, intent(in), optional :: allow_spaces Return Value logical procedure, public, pass(self) :: is_upper private elemental function is_upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value logical procedure, public, pass(self) :: start_with private elemental function start_with(self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: prefix integer, intent(in), optional :: start integer, intent(in), optional :: end Return Value logical generic, public :: assignment(=) => string_assign_string, string_assign_character, string_assign_integer_I1P, string_assign_integer_I2P, string_assign_integer_I4P, string_assign_integer_I8P, string_assign_real_R4P, string_assign_real_R8P private elemental subroutine string_assign_string(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs type( string ), intent(in) :: rhs private elemental subroutine string_assign_character(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs character(kind=CK,len=*), intent(in) :: rhs private elemental subroutine string_assign_integer_I1P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs integer(kind=I1P), intent(in) :: rhs private elemental subroutine string_assign_integer_I2P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs integer(kind=I2P), intent(in) :: rhs private elemental subroutine string_assign_integer_I4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs integer(kind=I4P), intent(in) :: rhs private elemental subroutine string_assign_integer_I8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs integer(kind=I8P), intent(in) :: rhs private elemental subroutine string_assign_real_R4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs real(kind=R4P), intent(in) :: rhs private elemental subroutine string_assign_real_R8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs real(kind=R8P), intent(in) :: rhs generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string private pure function string_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value character(kind=CK,len=:),\n  allocatable private pure function string_concat_character(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value character(kind=CK,len=:),\n  allocatable private pure function character_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value character(kind=CK,len=:),\n  allocatable generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string private elemental function string_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value type( string ) private elemental function string_concat_character_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value type( string ) private elemental function character_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value type( string ) generic, public :: operator(==) => string_eq_string, string_eq_character, character_eq_string private elemental function string_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value logical private elemental function string_eq_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value logical private elemental function character_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value logical generic, public :: operator(/=) => string_ne_string, string_ne_character, character_ne_string private elemental function string_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value logical private elemental function string_ne_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value logical private elemental function character_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value logical generic, public :: operator(<) => string_lt_string, string_lt_character, character_lt_string private elemental function string_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value logical private elemental function string_lt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value logical private elemental function character_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value logical generic, public :: operator(<=) => string_le_string, string_le_character, character_le_string private elemental function string_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value logical private elemental function string_le_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value logical private elemental function character_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value logical generic, public :: operator(>=) => string_ge_string, string_ge_character, character_ge_string private elemental function string_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value logical private elemental function string_ge_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value logical private elemental function character_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value logical generic, public :: operator(>) => string_gt_string, string_gt_character, character_gt_string private elemental function string_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs type( string ), intent(in) :: rhs Return Value logical private elemental function string_gt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs character(kind=CK,len=*), intent(in) :: rhs Return Value logical private elemental function character_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs class( string ), intent(in) :: rhs Return Value logical","tags":"","loc":"type/string.html"},{"title":"xml_tag – FoXy","text":"public interface xml_tag Contents Module Procedures create_tag_flat create_tag_nested Module Procedures private pure function create_tag_flat(name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, indent, is_content_indented, is_self_closing) result(tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: attribute (1:) character(len=*), intent(in), optional :: attributes (1:,1:) character(len=*), intent(in), optional :: attributes_stream logical, intent(in), optional :: sanitize_attributes_value character(len=*), intent(in), optional :: content integer(kind=I4P), intent(in), optional :: indent logical, intent(in), optional :: is_content_indented logical, intent(in), optional :: is_self_closing Return Value type( xml_tag ) private pure function create_tag_nested(name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, indent, is_content_indented) result(tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type( xml_tag ), intent(in) :: content character(len=*), intent(in), optional :: attribute (1:) character(len=*), intent(in), optional :: attributes (1:,1:) character(len=*), intent(in), optional :: attributes_stream logical, intent(in), optional :: sanitize_attributes_value integer(kind=I4P), intent(in), optional :: indent logical, intent(in), optional :: is_content_indented Return Value type( xml_tag )","tags":"","loc":"interface/xml_tag.html"},{"title":"sadjustl_character – FoXy","text":"public pure function sadjustl_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable Contents None","tags":"","loc":"proc/sadjustl_character.html"},{"title":"sadjustr_character – FoXy","text":"public pure function sadjustr_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable Contents None","tags":"","loc":"proc/sadjustr_character.html"},{"title":"sindex_string_string – FoXy","text":"public elemental function sindex_string_string(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/sindex_string_string.html"},{"title":"sindex_string_character – FoXy","text":"public elemental function sindex_string_character(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/sindex_string_character.html"},{"title":"sindex_character_string – FoXy","text":"public elemental function sindex_character_string(string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/sindex_character_string.html"},{"title":"slen – FoXy","text":"public elemental function slen(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/slen.html"},{"title":"slen_trim – FoXy","text":"public elemental function slen_trim(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/slen_trim.html"},{"title":"srepeat_string_string – FoXy","text":"public elemental function srepeat_string_string(self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: ncopies Return Value type( string ) Contents None","tags":"","loc":"proc/srepeat_string_string.html"},{"title":"sscan_string_string – FoXy","text":"public elemental function sscan_string_string(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/sscan_string_string.html"},{"title":"sscan_string_character – FoXy","text":"public elemental function sscan_string_character(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/sscan_string_character.html"},{"title":"sscan_character_string – FoXy","text":"public elemental function sscan_character_string(sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/sscan_character_string.html"},{"title":"strim – FoXy","text":"public elemental function strim(self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) Contents None","tags":"","loc":"proc/strim.html"},{"title":"read_file – FoXy","text":"public subroutine read_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file type( string ), intent(out), allocatable :: lines (:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg Contents None","tags":"","loc":"proc/read_file.html"},{"title":"read_lines – FoXy","text":"public subroutine read_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( string ), intent(out), allocatable :: lines (:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg Contents None","tags":"","loc":"proc/read_lines.html"},{"title":"write_lines – FoXy","text":"public subroutine write_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( string ), intent(in) :: lines (1:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg Contents None","tags":"","loc":"proc/write_lines.html"},{"title":"write_file – FoXy","text":"public subroutine write_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file type( string ), intent(in) :: lines (1:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg Contents None","tags":"","loc":"proc/write_file.html"},{"title":"adjustl – FoXy","text":"public interface adjustl Contents Module Procedures sadjustl_character Module Procedures public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable","tags":"","loc":"interface/adjustl.html"},{"title":"adjustr – FoXy","text":"public interface adjustr Contents Module Procedures sadjustr_character Module Procedures public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable","tags":"","loc":"interface/adjustr.html"},{"title":"count – FoXy","text":"public interface count Contents Module Procedures count_substring Module Procedures private elemental function count_substring(string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ character(len=*), intent(in) :: substring Return Value integer(kind=I4P)","tags":"","loc":"interface/count.html"},{"title":"index – FoXy","text":"public interface index Contents Module Procedures sindex_string_string sindex_string_character sindex_character_string Module Procedures public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/index.html"},{"title":"len – FoXy","text":"public interface len Contents Module Procedures slen Module Procedures public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer","tags":"","loc":"interface/len.html"},{"title":"len_trim – FoXy","text":"public interface len_trim Contents Module Procedures slen_trim Module Procedures public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer","tags":"","loc":"interface/len_trim.html"},{"title":"repeat – FoXy","text":"public interface repeat Contents Module Procedures srepeat_string_string Module Procedures public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: ncopies Return Value type( string )","tags":"","loc":"interface/repeat.html"},{"title":"scan – FoXy","text":"public interface scan Contents Module Procedures sscan_string_string sscan_string_character sscan_character_string Module Procedures public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/scan.html"},{"title":"trim – FoXy","text":"public interface trim Contents Module Procedures strim Module Procedures public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string )","tags":"","loc":"interface/trim.html"},{"title":"pack_data – FoXy","text":"public interface pack_data Contents Module Procedures pack_data_R8_R4 pack_data_R8_I8 pack_data_R8_I4 pack_data_R8_I2 pack_data_R8_I1 pack_data_R4_R8 pack_data_R4_I8 pack_data_R4_I4 pack_data_R4_I2 pack_data_R4_I1 pack_data_I8_R8 pack_data_I8_R4 pack_data_I8_I4 pack_data_I8_I2 pack_data_I8_I1 pack_data_I4_R8 pack_data_I4_R4 pack_data_I4_I8 pack_data_I4_I2 pack_data_I4_I1 pack_data_I2_R8 pack_data_I2_R4 pack_data_I2_I8 pack_data_I2_I4 pack_data_I2_I1 pack_data_I1_R8 pack_data_I1_R4 pack_data_I1_I8 pack_data_I1_I4 pack_data_I1_I2 Module Procedures private pure subroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:)","tags":"","loc":"interface/pack_data.html"},{"title":"b64_init – FoXy","text":"public subroutine b64_init() Arguments None Contents None","tags":"","loc":"proc/b64_init.html"},{"title":"b64_encode_up – FoXy","text":"public subroutine b64_encode_up(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up character(len=:), intent(out), allocatable :: code Contents None","tags":"","loc":"proc/b64_encode_up.html"},{"title":"b64_decode_up – FoXy","text":"public subroutine b64_decode_up(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code class(*), intent(out) :: up Contents None","tags":"","loc":"proc/b64_decode_up.html"},{"title":"b64_encode – FoXy","text":"public interface b64_encode Contents Module Procedures b64_encode_R8 b64_encode_R8_a b64_encode_R4 b64_encode_R4_a b64_encode_I8 b64_encode_I8_a b64_encode_I4 b64_encode_I4_a b64_encode_I2 b64_encode_I2_a b64_encode_I1 b64_encode_I1_a b64_encode_string b64_encode_string_a Module Procedures private pure subroutine b64_encode_R8(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_R8_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_R4(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_R4_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I8(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I8_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I4(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I4_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I2(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I2_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I1(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I1_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_string(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_string_a(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) character(len=:), intent(out), allocatable :: code","tags":"","loc":"interface/b64_encode.html"},{"title":"b64_decode – FoXy","text":"public interface b64_decode Contents Module Procedures b64_decode_R8 b64_decode_R8_a b64_decode_R4 b64_decode_R4_a b64_decode_I8 b64_decode_I8_a b64_decode_I4 b64_decode_I4_a b64_decode_I2 b64_decode_I2_a b64_decode_I1 b64_decode_I1_a b64_decode_string b64_decode_string_a Module Procedures private elemental subroutine b64_decode_R8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R8P), intent(out) :: n private pure subroutine b64_decode_R8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R8P), intent(out) :: n (1:) private elemental subroutine b64_decode_R4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R4P), intent(out) :: n private pure subroutine b64_decode_R4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R4P), intent(out) :: n (1:) private elemental subroutine b64_decode_I8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I8P), intent(out) :: n private pure subroutine b64_decode_I8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I8P), intent(out) :: n (1:) private elemental subroutine b64_decode_I4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I4P), intent(out) :: n private pure subroutine b64_decode_I4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I4P), intent(out) :: n (1:) private elemental subroutine b64_decode_I2(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I2P), intent(out) :: n private pure subroutine b64_decode_I2_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I2P), intent(out) :: n (1:) private elemental subroutine b64_decode_I1(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I1P), intent(out) :: n private pure subroutine b64_decode_I1_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I1P), intent(out) :: n (1:) private elemental subroutine b64_decode_string(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code character(len=*), intent(out) :: s private pure subroutine b64_decode_string_a(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code character(len=*), intent(out) :: s (1:)","tags":"","loc":"interface/b64_decode.html"},{"title":"str_ascii – FoXy","text":"public interface str_ascii Contents Module Procedures str_ascii_default Module Procedures private pure function str_ascii_default(input) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(kind=len=:,ASCII),\n  allocatable","tags":"","loc":"interface/str_ascii.html"},{"title":"str_ucs4 – FoXy","text":"public interface str_ucs4 Contents Module Procedures str_ucs4_default Module Procedures private pure function str_ucs4_default(input) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(kind=len=:,UCS4),\n  allocatable","tags":"","loc":"interface/str_ucs4.html"},{"title":"str – FoXy","text":"public interface str Contents Module Procedures strf_R8P str_R8P strf_R4P str_R4P strf_I8P str_I8P strf_I4P str_I4P strf_I2P str_I2P strf_I1P str_I1P str_bol str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P Module Procedures private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm real(kind=R8P), intent(in) :: n Return Value character(len=DR8P) private elemental function str_R8P(n, no_sign, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n logical, intent(in), optional :: no_sign logical, intent(in), optional :: compact Return Value character(len=DR8P) private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm real(kind=R4P), intent(in) :: n Return Value character(len=DR4P) private elemental function str_R4P(n, no_sign, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n logical, intent(in), optional :: no_sign logical, intent(in), optional :: compact Return Value character(len=DR4P) private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI8P) private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI4P) private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI2P) private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI1P) private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Return Value character(len=1) private pure function str_a_R8P(n, no_sign, separator, delimiters, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) logical, intent(in), optional :: compact Return Value character(len=:),\n  allocatable private pure function str_a_R4P(n, no_sign, separator, delimiters, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) logical, intent(in), optional :: compact Return Value character(len=:),\n  allocatable private pure function str_a_I8P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable private pure function str_a_I4P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable private pure function str_a_I2P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable private pure function str_a_I1P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/str.html"},{"title":"strz – FoXy","text":"public interface strz Contents Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P Module Procedures private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI8P) private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI4P) private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI2P) private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI1P)","tags":"","loc":"interface/strz.html"},{"title":"cton – FoXy","text":"public interface cton Contents Module Procedures ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Module Procedures private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R8P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value real(kind=R8P) private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R4P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value real(kind=R4P) private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I8P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I8P) private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I4P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I4P) private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I2P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I2P) private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I1P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I1P)","tags":"","loc":"interface/cton.html"},{"title":"bstr – FoXy","text":"public interface bstr Contents Module Procedures bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P Module Procedures private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Return Value character(len=64) private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Return Value character(len=32) private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Return Value character(len=64) private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Return Value character(len=32) private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Return Value character(len=16) private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Return Value character(len=8)","tags":"","loc":"interface/bstr.html"},{"title":"bcton – FoXy","text":"public interface bcton Contents Module Procedures bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Module Procedures private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr real(kind=R8P), intent(in) :: knd Return Value real(kind=R8P) private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr real(kind=R4P), intent(in) :: knd Return Value real(kind=R4P) private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I8P), intent(in) :: knd Return Value integer(kind=I8P) private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I4P), intent(in) :: knd Return Value integer(kind=I4P) private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I2P), intent(in) :: knd Return Value integer(kind=I2P) private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I1P), intent(in) :: knd Return Value integer(kind=I1P)","tags":"","loc":"interface/bcton.html"},{"title":"check_endian – FoXy","text":"public subroutine check_endian() Note The result is stored into the endian global variable. Arguments None Contents None","tags":"","loc":"proc/check_endian.html"},{"title":"penf_init – FoXy","text":"public subroutine penf_init() Arguments None Contents None","tags":"","loc":"proc/penf_init.html"},{"title":"penf_print – FoXy","text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: iostat character(len=*), intent(out), optional :: iomsg Contents None","tags":"","loc":"proc/penf_print.html"},{"title":"bit_size – FoXy","text":"public interface bit_size Contents None","tags":"","loc":"interface/bit_size.html"},{"title":"digit – FoXy","text":"public interface digit Contents Module Procedures digit_I8 digit_I4 digit_I2 digit_I1 Module Procedures private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Return Value integer(kind=I4P) private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Return Value integer(kind=I4P) private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Return Value integer(kind=I4P) private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Return Value integer(kind=I4P)","tags":"","loc":"interface/digit.html"},{"title":"bit_size – FoXy","text":"public interface bit_size Contents Module Procedures bit_size_R8P bit_size_R4P bit_size_chr Module Procedures private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Return Value integer(kind=I1P) private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Return Value integer(kind=I1P) private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Return Value integer(kind=I4P)","tags":"","loc":"interface/bit_size~2.html"},{"title":"byte_size – FoXy","text":"public interface byte_size Contents Module Procedures byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R8P byte_size_R4P byte_size_chr Module Procedures private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Return Value integer(kind=I4P)","tags":"","loc":"interface/byte_size.html"},{"title":"foxy_xml_file – FoXy","text":"Uses foxy_xml_tag penf Contents Derived Types xml_file Derived Types type, public :: xml_file Finalizations Procedures final :: finalize","tags":"","loc":"module/foxy_xml_file.html"},{"title":"foxy_xml_tag – FoXy","text":"Uses penf stringifor Contents Interfaces xml_tag Derived Types xml_tag Interfaces public interface xml_tag private pure function create_tag_flat(name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, indent, is_content_indented, is_self_closing) result(tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: attribute (1:) character(len=*), intent(in), optional :: attributes (1:,1:) character(len=*), intent(in), optional :: attributes_stream logical, intent(in), optional :: sanitize_attributes_value character(len=*), intent(in), optional :: content integer(kind=I4P), intent(in), optional :: indent logical, intent(in), optional :: is_content_indented logical, intent(in), optional :: is_self_closing Return Value type( xml_tag ) private pure function create_tag_nested(name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, indent, is_content_indented) result(tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type( xml_tag ), intent(in) :: content character(len=*), intent(in), optional :: attribute (1:) character(len=*), intent(in), optional :: attributes (1:,1:) character(len=*), intent(in), optional :: attributes_stream logical, intent(in), optional :: sanitize_attributes_value integer(kind=I4P), intent(in), optional :: indent logical, intent(in), optional :: is_content_indented Return Value type( xml_tag ) Derived Types type, public :: xml_tag Constructor private pure function create_tag_flat (name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, indent, is_content_indented, is_self_closing) private pure function create_tag_nested (name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, indent, is_content_indented) Type-Bound Procedures generic, public :: add_attributes => add_single_attribute, add_multiple_attributes, add_stream_attributes procedure, public, pass(self) :: attributes procedure, public, pass(self) :: get_content generic, public :: delete_attributes => delete_single_attribute, delete_multiple_attributes procedure, public, pass(self) :: delete_content procedure, public, pass(self) :: end_tag procedure, public, pass(self) :: free procedure, public, pass(self) :: is_attribute_present procedure, public, pass(self) :: is_parsed procedure, public, pass(self) :: name procedure, public, pass(self) :: parse procedure, public, pass(self) :: self_closing_tag procedure, public, pass(self) :: set procedure, public, pass(self) :: start_tag procedure, public, pass(self) :: stringify procedure, public, pass(self) :: write => write_tag generic, public :: assignment(=) => assign_tag","tags":"","loc":"module/foxy_xml_tag.html"},{"title":"foxy – FoXy","text":"Uses foxy_xml_file foxy_xml_tag penf Contents None","tags":"","loc":"module/foxy.html"},{"title":"stringifor_string_t – FoXy","text":"Uses iso_fortran_env befor64 penf Contents Variables CK Derived Types string Functions sadjustl_character sadjustr_character sindex_string_string sindex_string_character sindex_character_string slen slen_trim srepeat_string_string sscan_string_string sscan_string_character sscan_character_string strim Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Derived Types type, public :: string Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl procedure, public, pass(self) :: adjustr => sadjustr procedure, public, pass(self) :: count => scount generic, public :: index => sindex_string_string, sindex_string_character procedure, public, pass(self) :: len => slen procedure, public, pass(self) :: len_trim => slen_trim generic, public :: repeat => srepeat_string_string, srepeat_character_string generic, public :: scan => sscan_string_string, sscan_string_character procedure, public, pass(self) :: trim => strim procedure, public, pass(self) :: verify => sverify procedure, public, pass(self) :: basedir procedure, public, pass(self) :: basename procedure, public, pass(self) :: camelcase procedure, public, pass(self) :: capitalize procedure, public, pass(self) :: chars procedure, public, pass(self) :: decode procedure, public, pass(self) :: encode procedure, public, pass(self) :: escape procedure, public, pass(self) :: extension procedure, public, pass(self) :: fill procedure, public, pass(self) :: free generic, public :: glob => glob_character, glob_string generic, public :: insert => insert_string, insert_character generic, public :: join => join_strings, join_characters procedure, public, pass(self) :: lower procedure, public, pass(self) :: partition procedure, public, pass(self) :: read_file procedure, public, pass(self) :: read_line procedure, public, pass(self) :: read_lines procedure, public, pass(self) :: replace procedure, public, pass(self) :: reverse procedure, public, pass(self) :: search procedure, public, pass(self) :: slice procedure, public, pass(self) :: snakecase procedure, public, pass(self) :: split procedure, public, pass(self) :: split_chunked procedure, public, pass(self) :: startcase procedure, public, pass(self) :: strip procedure, public, pass(self) :: swapcase procedure, public, pass(self) :: tempname generic, public :: to_number => to_integer_I1P, to_integer_I2P, to_integer_I4P, to_integer_I8P, to_real_R4P, to_real_R8P procedure, public, pass(self) :: unescape procedure, public, pass(self) :: unique procedure, public, pass(self) :: upper procedure, public, pass(self) :: write_file procedure, public, pass(self) :: write_line procedure, public, pass(self) :: write_lines procedure, public, pass(self) :: end_with procedure, public, pass(self) :: is_allocated procedure, public, pass(self) :: is_digit procedure, public, pass(self) :: is_integer procedure, public, pass(self) :: is_lower procedure, public, pass(self) :: is_number procedure, public, pass(self) :: is_real procedure, public, pass(self) :: is_upper procedure, public, pass(self) :: start_with generic, public :: assignment(=) => string_assign_string, string_assign_character, string_assign_integer_I1P, string_assign_integer_I2P, string_assign_integer_I4P, string_assign_integer_I8P, string_assign_real_R4P, string_assign_real_R8P generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string generic, public :: operator(==) => string_eq_string, string_eq_character, character_eq_string generic, public :: operator(/=) => string_ne_string, string_ne_character, character_ne_string generic, public :: operator(<) => string_lt_string, string_lt_character, character_lt_string generic, public :: operator(<=) => string_le_string, string_le_character, character_le_string generic, public :: operator(>=) => string_ge_string, string_ge_character, character_ge_string generic, public :: operator(>) => string_gt_string, string_gt_character, character_gt_string Functions public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: ncopies Return Value type( string ) public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string )","tags":"","loc":"module/stringifor_string_t.html"},{"title":"stringifor – FoXy","text":"Uses penf stringifor_string_t Contents Interfaces adjustl adjustr count index len len_trim repeat scan trim Subroutines read_file read_lines write_lines write_file Interfaces public interface adjustl public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable public interface adjustr public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(kind=CK,len=:),\n  allocatable public interface count private elemental function count_substring(string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ character(len=*), intent(in) :: substring Return Value integer(kind=I4P) public interface index public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ type( string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public interface len public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer public interface len_trim public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer public interface repeat public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: ncopies Return Value type( string ) public interface scan public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(kind=CK,len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring type( string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public interface trim public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) Subroutines public subroutine read_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file type( string ), intent(out), allocatable :: lines (:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg public subroutine read_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( string ), intent(out), allocatable :: lines (:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg public subroutine write_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( string ), intent(in) :: lines (1:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg public subroutine write_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file type( string ), intent(in) :: lines (1:) character(len=*), intent(in), optional :: form integer, intent(out), optional :: iostat character(len=*), intent(inout), optional :: iomsg","tags":"","loc":"module/stringifor.html"},{"title":"befor64_pack_data_m – FoXy","text":"Uses penf Contents Interfaces pack_data Interfaces public interface pack_data private pure subroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) integer(kind=I1P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) real(kind=R8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) real(kind=R4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) integer(kind=I8P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) integer(kind=I4P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:) private pure subroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) integer(kind=I2P), intent(in) :: a2 (1:) integer(kind=I1P), intent(inout), allocatable :: packed (:)","tags":"","loc":"module/befor64_pack_data_m.html"},{"title":"befor64 – FoXy","text":"Uses penf befor64_pack_data_m Contents Variables is_b64_initialized Interfaces b64_encode b64_decode Subroutines b64_init b64_encode_up b64_decode_up Variables Type Visibility Attributes Name Initial logical, public :: is_b64_initialized = .false. Interfaces public interface b64_encode private pure subroutine b64_encode_R8(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_R8_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_R4(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_R4_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I8(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I8_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I4(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I4_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I2(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I2_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I1(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_I1_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_string(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=:), intent(out), allocatable :: code private pure subroutine b64_encode_string_a(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) character(len=:), intent(out), allocatable :: code public interface b64_decode private elemental subroutine b64_decode_R8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R8P), intent(out) :: n private pure subroutine b64_decode_R8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R8P), intent(out) :: n (1:) private elemental subroutine b64_decode_R4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R4P), intent(out) :: n private pure subroutine b64_decode_R4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code real(kind=R4P), intent(out) :: n (1:) private elemental subroutine b64_decode_I8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I8P), intent(out) :: n private pure subroutine b64_decode_I8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I8P), intent(out) :: n (1:) private elemental subroutine b64_decode_I4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I4P), intent(out) :: n private pure subroutine b64_decode_I4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I4P), intent(out) :: n (1:) private elemental subroutine b64_decode_I2(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I2P), intent(out) :: n private pure subroutine b64_decode_I2_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I2P), intent(out) :: n (1:) private elemental subroutine b64_decode_I1(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I1P), intent(out) :: n private pure subroutine b64_decode_I1_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code integer(kind=I1P), intent(out) :: n (1:) private elemental subroutine b64_decode_string(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code character(len=*), intent(out) :: s private pure subroutine b64_decode_string_a(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code character(len=*), intent(out) :: s (1:) Subroutines public subroutine b64_init () Arguments None public subroutine b64_encode_up (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up character(len=:), intent(out), allocatable :: code public subroutine b64_decode_up (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code class(*), intent(out) :: up","tags":"","loc":"module/befor64.html"},{"title":"penf_stringify – FoXy","text":"Uses iso_fortran_env penf_b_size penf_global_parameters_variables Contents Interfaces str_ascii str_ucs4 str strz cton bstr bcton Interfaces public interface str_ascii private pure function str_ascii_default(input) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(kind=len=:,ASCII),\n  allocatable public interface str_ucs4 private pure function str_ucs4_default(input) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(kind=len=:,UCS4),\n  allocatable public interface str private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm real(kind=R8P), intent(in) :: n Return Value character(len=DR8P) private elemental function str_R8P(n, no_sign, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n logical, intent(in), optional :: no_sign logical, intent(in), optional :: compact Return Value character(len=DR8P) private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm real(kind=R4P), intent(in) :: n Return Value character(len=DR4P) private elemental function str_R4P(n, no_sign, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n logical, intent(in), optional :: no_sign logical, intent(in), optional :: compact Return Value character(len=DR4P) private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI8P) private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI4P) private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI2P) private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n logical, intent(in), optional :: no_sign Return Value character(len=DI1P) private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Return Value character(len=1) private pure function str_a_R8P(n, no_sign, separator, delimiters, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) logical, intent(in), optional :: compact Return Value character(len=:),\n  allocatable private pure function str_a_R4P(n, no_sign, separator, delimiters, compact) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) logical, intent(in), optional :: compact Return Value character(len=:),\n  allocatable private pure function str_a_I8P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable private pure function str_a_I4P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable private pure function str_a_I2P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable private pure function str_a_I1P(n, no_sign, separator, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) logical, intent(in), optional :: no_sign character(len=1), intent(in), optional :: separator character(len=*), intent(in), optional :: delimiters (1:2) Return Value character(len=:),\n  allocatable public interface strz private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI8P) private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI4P) private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI2P) private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n integer(kind=I4P), intent(in), optional :: nz_pad Return Value character(len=DI1P) public interface cton private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R8P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value real(kind=R8P) private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R4P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value real(kind=R4P) private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I8P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I8P) private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I4P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I4P) private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I2P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I2P) private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I1P), intent(in) :: knd character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: error Return Value integer(kind=I1P) public interface bstr private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Return Value character(len=64) private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Return Value character(len=32) private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Return Value character(len=64) private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Return Value character(len=32) private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Return Value character(len=16) private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Return Value character(len=8) public interface bcton private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr real(kind=R8P), intent(in) :: knd Return Value real(kind=R8P) private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr real(kind=R4P), intent(in) :: knd Return Value real(kind=R4P) private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I8P), intent(in) :: knd Return Value integer(kind=I8P) private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I4P), intent(in) :: knd Return Value integer(kind=I4P) private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I2P), intent(in) :: knd Return Value integer(kind=I2P) private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr integer(kind=I1P), intent(in) :: knd Return Value integer(kind=I1P)","tags":"","loc":"module/penf_stringify.html"},{"title":"penf – FoXy","text":"Uses penf_global_parameters_variables penf_b_size penf_stringify Contents Variables endian is_initialized Interfaces bit_size digit Subroutines check_endian penf_init penf_print Variables Type Visibility Attributes Name Initial integer, public :: endian = endianL logical, public :: is_initialized = .false. Interfaces public interface bit_size public interface digit private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Return Value integer(kind=I4P) private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Return Value integer(kind=I4P) private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Return Value integer(kind=I4P) private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Return Value integer(kind=I4P) Subroutines public subroutine check_endian () Read more… Arguments None public subroutine penf_init () Arguments None public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit character(len=*), intent(in), optional :: pref integer(kind=I4P), intent(out), optional :: iostat character(len=*), intent(out), optional :: iomsg","tags":"","loc":"module/penf.html"},{"title":"penf_global_parameters_variables – FoXy","text":"Contents Variables endianL endianB ASCII UCS4 CK R16P R8P R4P R_P I8P I4P I2P I1P I_P FR16P FR8P FR4P FR_P FI8P FI8PZP FI4P FI4PZP FI2P FI2PZP FI1P FI1PZP FI_P FI_PZP DR16P DR8P DR4P DR_P DI8P DI4P DI2P DI1P DI_P CHARACTER_KINDS_LIST REAL_KINDS_LIST REAL_FORMATS_LIST INTEGER_KINDS_LIST INTEGER_FORMATS_LIST MinR16P MaxR16P MinR8P MaxR8P MinR4P MaxR4P MinR_P MaxR_P MinI8P MinI4P MinI2P MinI1P MinI_P MaxI8P MaxI4P MaxI2P MaxI1P MaxI_P smallR16P smallR8P smallR4P smallR_P ZeroR16P ZeroR8P ZeroR4P ZeroR_P BIR16P BIR8P BIR4P BIR_P BYR16P BYR8P BYR4P BYR_P BII8P BII4P BII2P BII1P BII_P BYI8P BYI4P BYI2P BYI1P BYI_P Variables Type Visibility Attributes Name Initial integer, public, parameter :: endianL = 1 integer, public, parameter :: endianB = 0 integer, public, parameter :: ASCII = selected_char_kind('default') integer, public, parameter :: UCS4 = selected_char_kind('default') integer, public, parameter :: CK = selected_char_kind('default') integer, public, parameter :: R16P = selected_real_kind(15, 307) integer, public, parameter :: R8P = selected_real_kind(15, 307) integer, public, parameter :: R4P = selected_real_kind(6, 37) integer, public, parameter :: R_P = R8P integer, public, parameter :: I8P = selected_int_kind(18) integer, public, parameter :: I4P = selected_int_kind(9) integer, public, parameter :: I2P = selected_int_kind(4) integer, public, parameter :: I1P = selected_int_kind(2) integer, public, parameter :: I_P = I4P character(len=*), public, parameter :: FR16P = '(E23.15E3)' character(len=*), public, parameter :: FR8P = '(E23.15E3)' character(len=*), public, parameter :: FR4P = '(E13.6E2)' character(len=*), public, parameter :: FR_P = FR8P character(len=*), public, parameter :: FI8P = '(I20)' character(len=*), public, parameter :: FI8PZP = '(I20.19)' character(len=*), public, parameter :: FI4P = '(I11)' character(len=*), public, parameter :: FI4PZP = '(I11.10)' character(len=*), public, parameter :: FI2P = '(I6)' character(len=*), public, parameter :: FI2PZP = '(I6.5)' character(len=*), public, parameter :: FI1P = '(I4)' character(len=*), public, parameter :: FI1PZP = '(I4.3)' character(len=*), public, parameter :: FI_P = FI4P character(len=*), public, parameter :: FI_PZP = FI4PZP integer, public, parameter :: DR16P = 23 integer, public, parameter :: DR8P = 23 integer, public, parameter :: DR4P = 13 integer, public, parameter :: DR_P = DR8P integer, public, parameter :: DI8P = 20 integer, public, parameter :: DI4P = 11 integer, public, parameter :: DI2P = 6 integer, public, parameter :: DI1P = 4 integer, public, parameter :: DI_P = DI4P integer, public, parameter :: CHARACTER_KINDS_LIST (1:3) = [ASCII, UCS4, CK] integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) real(kind=R_P), public, parameter :: MinR_P = -huge(1._R_P) real(kind=R_P), public, parameter :: MaxR_P = huge(1._R_P) integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) integer(kind=I_P), public, parameter :: MinI_P = -huge(1_I_P) integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) integer(kind=I_P), public, parameter :: MaxI_P = huge(1_I_P) real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) real(kind=R_P), public, parameter :: smallR_P = tiny(1._R_P) real(kind=R16P), public, parameter :: ZeroR16P = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) real(kind=R8P), public, parameter :: ZeroR8P = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) real(kind=R4P), public, parameter :: ZeroR4P = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) real(kind=R_P), public, parameter :: ZeroR_P = nearest(1._R_P, 1._R_P)-nearest(1._R_P, -1._R_P) integer(kind=I2P), public :: BIR16P integer(kind=I1P), public :: BIR8P integer(kind=I1P), public :: BIR4P integer(kind=I1P), public :: BIR_P integer(kind=I2P), public :: BYR16P integer(kind=I1P), public :: BYR8P integer(kind=I1P), public :: BYR4P integer(kind=I1P), public :: BYR_P integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P","tags":"","loc":"module/penf_global_parameters_variables.html"},{"title":"penf_b_size – FoXy","text":"Uses penf_global_parameters_variables Contents Interfaces bit_size byte_size Interfaces public interface bit_size private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Return Value integer(kind=I1P) private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Return Value integer(kind=I1P) private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Return Value integer(kind=I4P) public interface byte_size private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Return Value integer(kind=I1P) private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Return Value integer(kind=I4P)","tags":"","loc":"module/penf_b_size.html"},{"title":"add_attributes – FoXy","text":"Uses foxy Contents Variables source parsed a_tag test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_tag ) :: a_tag logical :: test_passed (3)","tags":"","loc":"program/add_attributes.html"},{"title":"parse_string_simple – FoXy","text":"Uses foxy Contents Variables source parsed xfile test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_file ) :: xfile logical :: test_passed (1)","tags":"","loc":"program/parse_string_simple.html"},{"title":"delete_content – FoXy","text":"Uses foxy Contents Variables source parsed a_tag test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_tag ) :: a_tag logical :: test_passed (1)","tags":"","loc":"program/delete_content.html"},{"title":"create_tag – FoXy","text":"Uses foxy Contents Variables source parsed a_tag test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_tag ) :: a_tag logical :: test_passed (4)","tags":"","loc":"program/create_tag.html"},{"title":"add_tag – FoXy","text":"Uses foxy Contents Variables source parsed a_file a_tag another_tag test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_file ) :: a_file type( xml_tag ) :: a_tag type( xml_tag ) :: another_tag logical :: test_passed (1)","tags":"","loc":"program/add_tag.html"},{"title":"delete_attributes – FoXy","text":"Uses foxy Contents Variables source parsed a_tag test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_tag ) :: a_tag logical :: test_passed (4)","tags":"","loc":"program/delete_attributes.html"},{"title":"write_tag – FoXy","text":"Uses foxy Contents Variables source parsed a_tag xfile xunit test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_tag ) :: a_tag type( xml_file ) :: xfile integer :: xunit logical :: test_passed (3)","tags":"","loc":"program/write_tag.html"},{"title":"parse_file_simple – FoXy","text":"Uses foxy Contents Variables source parsed xfile xunit test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_file ) :: xfile integer :: xunit logical :: test_passed (1)","tags":"","loc":"program/parse_file_simple.html"},{"title":"delete_tag – FoXy","text":"Uses foxy Contents Variables source parsed a_file a_tag another_tag test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_file ) :: a_file type( xml_tag ) :: a_tag type( xml_tag ) :: another_tag logical :: test_passed (2)","tags":"","loc":"program/delete_tag.html"},{"title":"indent_tag – FoXy","text":"Uses foxy Contents Variables source parsed a_tag test_passed Variables Type Attributes Name Initial character(len=:), allocatable :: source character(len=:), allocatable :: parsed type( xml_tag ) :: a_tag logical :: test_passed (2)","tags":"","loc":"program/indent_tag.html"},{"title":"concatenation – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring yetanotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ) :: yetanotherstring character(len=:), allocatable :: acharacter logical :: test_passed (6)","tags":"","loc":"program/concatenation.html"},{"title":"split – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring strings test_passed s Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) logical :: test_passed (12) integer :: s","tags":"","loc":"program/split.html"},{"title":"read_file – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring strings line iostat iomsg scratch l test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (17)","tags":"","loc":"program/read_file.html"},{"title":"free – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2)","tags":"","loc":"program/free.html"},{"title":"replace – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3)","tags":"","loc":"program/replace.html"},{"title":"glob – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring alist_str alist_chr Nf files file_unit f ff test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: alist_str (:) character(len=:), allocatable :: alist_chr (:) integer, parameter :: Nf = 5 character(len=14) :: files (1:Nf) integer :: file_unit integer :: f integer :: ff logical :: test_passed (2)","tags":"","loc":"program/glob.html"},{"title":"startcase – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/startcase.html"},{"title":"swapcase – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/swapcase.html"},{"title":"strim – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2)","tags":"","loc":"program/strim.html"},{"title":"srepeat – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3)","tags":"","loc":"program/srepeat.html"},{"title":"escape – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/escape.html"},{"title":"fill – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4)","tags":"","loc":"program/fill.html"},{"title":"read_lines – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring strings line iostat iomsg scratch l test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (16)","tags":"","loc":"program/read_lines.html"},{"title":"extension – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/extension.html"},{"title":"read_line – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring line iostat iomsg scratch l test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (6)","tags":"","loc":"program/read_line.html"},{"title":"slice – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/slice.html"},{"title":"sindex – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring acharacter anothercharacter i ic test_passed Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter character(len=:), allocatable :: anothercharacter integer :: i integer :: ic logical :: test_passed (6)","tags":"","loc":"program/sindex.html"},{"title":"count_string – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring No test_passed Variables Type Attributes Name Initial type( string ) :: astring integer :: No logical :: test_passed (3)","tags":"","loc":"program/count_string.html"},{"title":"is_integer – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (6)","tags":"","loc":"program/is_integer.html"},{"title":"is_number – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (7)","tags":"","loc":"program/is_number.html"},{"title":"join – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring strings characters test_passed s Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: strings (3) character(len=5) :: characters (3) logical :: test_passed (11) integer :: s","tags":"","loc":"program/join.html"},{"title":"upper_lower – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1:8)","tags":"","loc":"program/upper_lower.html"},{"title":"search – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter istart iend test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed (5)","tags":"","loc":"program/search.html"},{"title":"tempname – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring tmpname test_passed Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: tmpname logical :: test_passed (5)","tags":"","loc":"program/tempname.html"},{"title":"equal – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter logical :: test_passed (6)","tags":"","loc":"program/equal.html"},{"title":"io_formatted – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables test_passed Variables Type Attributes Name Initial logical :: test_passed (4)","tags":"","loc":"program/io_formatted.html"},{"title":"sadjustlr – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4)","tags":"","loc":"program/sadjustlr.html"},{"title":"sscan – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter anothercharacter i ic test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter character(len=:), allocatable :: anothercharacter integer :: i integer :: ic logical :: test_passed (5)","tags":"","loc":"program/sscan.html"},{"title":"is_digit – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2)","tags":"","loc":"program/is_digit.html"},{"title":"io_basic – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables test_passed Variables Type Attributes Name Initial logical :: test_passed (2)","tags":"","loc":"program/io_basic.html"},{"title":"basename_dir – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (8)","tags":"","loc":"program/basename_dir.html"},{"title":"slen – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4)","tags":"","loc":"program/slen.html"},{"title":"greater_than – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter logical :: test_passed (6)","tags":"","loc":"program/greater_than.html"},{"title":"greater_equal_than – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter logical :: test_passed (9)","tags":"","loc":"program/greater_equal_than.html"},{"title":"to_number – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring integer_I1P integer_I1P_ integer_I2P integer_I2P_ integer_I4P integer_I4P_ integer_I8P integer_I8P_ real_R4P real_R4P_ real_R8P real_R8P_ real_R16P real_R16P_ test_passed Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I1P) :: integer_I1P integer(kind=I1P) :: integer_I1P_ integer(kind=I2P) :: integer_I2P integer(kind=I2P) :: integer_I2P_ integer(kind=I4P) :: integer_I4P integer(kind=I4P) :: integer_I4P_ integer(kind=I8P) :: integer_I8P integer(kind=I8P) :: integer_I8P_ real(kind=R4P) :: real_R4P real(kind=R4P) :: real_R4P_ real(kind=R8P) :: real_R8P real(kind=R8P) :: real_R8P_ real(kind=R16P) :: real_R16P real(kind=R16P) :: real_R16P_ logical :: test_passed (7)","tags":"","loc":"program/to_number.html"},{"title":"lower_equal_than – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter logical :: test_passed (9)","tags":"","loc":"program/lower_equal_than.html"},{"title":"snakecase – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/snakecase.html"},{"title":"stringifor_test_assignments – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring ainteger_I1P ainteger_I2P ainteger_I4P ainteger_I8P areal_R4P areal_R8P areal_R16P test_passed Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I1P) :: ainteger_I1P integer(kind=I2P) :: ainteger_I2P integer(kind=I4P) :: ainteger_I4P integer(kind=I8P) :: ainteger_I8P real(kind=R4P) :: areal_R4P real(kind=R8P) :: areal_R8P real(kind=R16P) :: areal_R16P logical :: test_passed (7)","tags":"","loc":"program/stringifor_test_assignments.html"},{"title":"partition – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring strings test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: strings (3) logical :: test_passed (3)","tags":"","loc":"program/partition.html"},{"title":"encode – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/encode.html"},{"title":"reverse – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2)","tags":"","loc":"program/reverse.html"},{"title":"csv_naive_parser – FoXy","text":"Uses stringifor Contents Variables csv rows columns cells lines most_expensive highest_cost rows_number columns_number r test_passed Variables Type Attributes Name Initial type( string ) :: csv type( string ), allocatable :: rows (:) type( string ), allocatable :: columns (:) type( string ), allocatable :: cells (:,:) type( string ) :: lines (4) type( string ) :: most_expensive real(kind=R8P) :: highest_cost integer :: rows_number integer :: columns_number integer :: r logical :: test_passed (1)","tags":"","loc":"program/csv_naive_parser.html"},{"title":"not_equal – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter logical :: test_passed (6)","tags":"","loc":"program/not_equal.html"},{"title":"camelcase – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/camelcase.html"},{"title":"is_real – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (6)","tags":"","loc":"program/is_real.html"},{"title":"sverify – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring acharacter anothercharacter i ic test_passed Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter character(len=:), allocatable :: anothercharacter integer :: i integer :: ic logical :: test_passed (3)","tags":"","loc":"program/sverify.html"},{"title":"write_lines – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring strings line iostat iomsg scratch l test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (16)","tags":"","loc":"program/write_lines.html"},{"title":"unique – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/unique.html"},{"title":"write_file – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring strings line iostat iomsg scratch l test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (16)","tags":"","loc":"program/write_file.html"},{"title":"start_end – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (9)","tags":"","loc":"program/start_end.html"},{"title":"strip – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/strip.html"},{"title":"insert – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter logical :: test_passed (10)","tags":"","loc":"program/insert.html"},{"title":"capitalize – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/capitalize.html"},{"title":"unescape – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2)","tags":"","loc":"program/unescape.html"},{"title":"decode – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring test_passed Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1)","tags":"","loc":"program/decode.html"},{"title":"lower_than – FoXy","text":"Uses iso_fortran_env stringifor Contents Variables astring anotherstring acharacter test_passed Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter logical :: test_passed (6)","tags":"","loc":"program/lower_than.html"},{"title":"stringifor_test_parse_large_csv – FoXy","text":"Uses stringifor Contents Variables csv rows columns cells rows_number columns_number r test_passed Variables Type Attributes Name Initial type( string ) :: csv type( string ), allocatable :: rows (:) type( string ), allocatable :: columns (:) type( string ), allocatable :: cells (:,:) integer :: rows_number integer :: columns_number integer :: r logical :: test_passed (1)","tags":"","loc":"program/stringifor_test_parse_large_csv.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~2.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_I1 Variables Type Attributes Name Initial integer(kind=I1P) :: scalar_I1","tags":"","loc":"program/volatile_doctest~3.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~4.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_I8 Variables Type Attributes Name Initial integer(kind=I8P) :: array_I8 (1:4)","tags":"","loc":"program/volatile_doctest~5.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_I2 Variables Type Attributes Name Initial integer(kind=I2P) :: scalar_I2","tags":"","loc":"program/volatile_doctest~6.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~7.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~8.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_R8 Variables Type Attributes Name Initial real(kind=R8P) :: scalar_R8","tags":"","loc":"program/volatile_doctest~9.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~10.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_R16 Variables Type Attributes Name Initial real(kind=R16P) :: scalar_R16","tags":"","loc":"program/volatile_doctest~11.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_R16 Variables Type Attributes Name Initial real(kind=R16P) :: array_R16 (1:2)","tags":"","loc":"program/volatile_doctest~12.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_I1 Variables Type Attributes Name Initial integer(kind=I1P) :: array_I1 (1:2)","tags":"","loc":"program/volatile_doctest~13.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_I4 Variables Type Attributes Name Initial integer(kind=I4P) :: scalar_I4","tags":"","loc":"program/volatile_doctest~14.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_I8 Variables Type Attributes Name Initial integer(kind=I8P) :: scalar_I8","tags":"","loc":"program/volatile_doctest~15.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~16.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_R4 Variables Type Attributes Name Initial real(kind=R4P) :: scalar_R4","tags":"","loc":"program/volatile_doctest~17.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~18.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~19.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables scalar_I4 Variables Type Attributes Name Initial integer(kind=I4P) :: scalar_I4","tags":"","loc":"program/volatile_doctest~20.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_R4 Variables Type Attributes Name Initial real(kind=R4P) :: array_R4 (1:2)","tags":"","loc":"program/volatile_doctest~21.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_I2 Variables Type Attributes Name Initial integer(kind=I2P) :: array_I2 (1:2)","tags":"","loc":"program/volatile_doctest~22.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~23.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_I4 Variables Type Attributes Name Initial integer(kind=I4P) :: array_I4 (1:2)","tags":"","loc":"program/volatile_doctest~24.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~25.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~26.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~27.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~28.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_I8 Variables Type Attributes Name Initial integer(kind=I8P) :: array_I8 (1:4)","tags":"","loc":"program/volatile_doctest~29.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~30.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~31.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~32.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_R8 Variables Type Attributes Name Initial real(kind=R8P) :: array_R8 (1:2)","tags":"","loc":"program/volatile_doctest~33.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~34.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables array_s Variables Type Attributes Name Initial character(len=5) :: array_s (1:2)","tags":"","loc":"program/volatile_doctest~35.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 Contents None","tags":"","loc":"program/volatile_doctest~36.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64 befor64 penf Contents Variables code64 Variables Type Attributes Name Initial character(len=:), allocatable :: code64","tags":"","loc":"program/volatile_doctest~37.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I2P) :: a1 (1) integer(kind=I1P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~38.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I8P) :: a1 (1) real(kind=R4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~39.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I2P) :: a1 (1) real(kind=R4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~40.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R8P) :: a1 (1) integer(kind=I8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~41.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I8P) :: a1 (1) integer(kind=I1P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~42.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I2P) :: a1 (1) integer(kind=I8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~43.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I2P) :: a1 (1) integer(kind=I4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~44.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R8P) :: a1 (1) integer(kind=I2P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~45.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I4P) :: a1 (1) integer(kind=I8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~46.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I2P) :: a1 (1) real(kind=R8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~47.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I4P) :: a1 (1) integer(kind=I2P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~48.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I1P) :: a1 (1) real(kind=R8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~49.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I4P) :: a1 (1) real(kind=R4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~50.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I1P) :: a1 (1) real(kind=R4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~51.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R8P) :: a1 (1) integer(kind=I1P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~52.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R4P) :: a1 (1) integer(kind=I2P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~53.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R4P) :: a1 (1) real(kind=R8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~54.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R4P) :: a1 (1) integer(kind=I4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~55.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R4P) :: a1 (1) integer(kind=I1P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~56.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I8P) :: a1 (1) real(kind=R8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~57.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R4P) :: a1 (1) integer(kind=I8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~58.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R8P) :: a1 (1) real(kind=R4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~59.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I1P) :: a1 (1) integer(kind=I4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~60.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I8P) :: a1 (1) integer(kind=I4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~61.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I1P) :: a1 (1) integer(kind=I2P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~62.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I8P) :: a1 (1) integer(kind=I2P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~63.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial real(kind=R8P) :: a1 (1) integer(kind=I4P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~64.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I4P) :: a1 (1) real(kind=R8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~65.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I1P) :: a1 (1) integer(kind=I8P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~66.html"},{"title":"volatile_doctest – FoXy","text":"Uses befor64_pack_data_m befor64 penf Contents Variables a1 a2 pack Variables Type Attributes Name Initial integer(kind=I4P) :: a1 (1) integer(kind=I1P) :: a2 (1) integer(kind=I1P), allocatable :: pack (:)","tags":"","loc":"program/volatile_doctest~67.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf penf Contents None","tags":"","loc":"program/volatile_doctest~68.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf penf Contents Variables u Variables Type Attributes Name Initial integer :: u","tags":"","loc":"program/volatile_doctest~69.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf penf Contents None","tags":"","loc":"program/volatile_doctest~70.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf penf Contents None","tags":"","loc":"program/volatile_doctest~71.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf penf Contents None","tags":"","loc":"program/volatile_doctest~72.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf penf Contents None","tags":"","loc":"program/volatile_doctest~73.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf penf Contents None","tags":"","loc":"program/volatile_doctest~74.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~75.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~76.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~77.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~78.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~79.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~80.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~81.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~82.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~83.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~84.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~85.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_b_size penf Contents None","tags":"","loc":"program/volatile_doctest~86.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~87.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~88.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~89.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~90.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~91.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~92.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~93.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~94.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~95.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~96.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~97.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~98.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~99.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~100.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~101.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~102.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~103.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~104.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~105.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents Variables string Variables Type Attributes Name Initial character(kind=len=:,UCS4), allocatable :: string","tags":"","loc":"program/volatile_doctest~106.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~107.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~108.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~109.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~110.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents Variables b Variables Type Attributes Name Initial character(len=128) :: b","tags":"","loc":"program/volatile_doctest~111.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~112.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~113.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~114.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~115.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~116.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~117.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~118.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~119.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~120.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~121.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~122.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~123.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~124.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents Variables string Variables Type Attributes Name Initial character(kind=len=:,UCS4), allocatable :: string","tags":"","loc":"program/volatile_doctest~125.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents Variables string Variables Type Attributes Name Initial character(kind=len=:,ASCII), allocatable :: string","tags":"","loc":"program/volatile_doctest~126.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~127.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~128.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~129.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~130.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~131.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~132.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~133.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~134.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~135.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~136.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~137.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~138.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~139.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~140.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~141.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~142.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~143.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~144.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~145.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~146.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~147.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~148.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~149.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~150.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~151.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~152.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~153.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~154.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~155.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~156.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~157.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~158.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~159.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~160.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~161.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~162.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents Variables string Variables Type Attributes Name Initial character(kind=len=:,ASCII), allocatable :: string","tags":"","loc":"program/volatile_doctest~163.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~164.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~165.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~166.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents Variables string Variables Type Attributes Name Initial character(kind=len=:,ASCII), allocatable :: string","tags":"","loc":"program/volatile_doctest~167.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~168.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~169.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~170.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~171.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~172.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~173.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents Variables string Variables Type Attributes Name Initial character(kind=len=:,UCS4), allocatable :: string","tags":"","loc":"program/volatile_doctest~174.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~175.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~176.html"},{"title":"volatile_doctest – FoXy","text":"Uses penf_stringify penf Contents None","tags":"","loc":"program/volatile_doctest~177.html"}]}